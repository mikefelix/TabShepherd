// Generated by CoffeeScript 1.9.1
(function() {
  var TabShepherd, _, activeTabId, alert, alertText, assertAlert, assertNoOutput, assertOmni, assertText, changeInput, chrome, defs, enterInput, expectNoResponseFor, expectResponseFor, expectSuggestionFor, focusedWindowId, inputChanged, inputEntered, omniboxText, randomId, reset, suggest, tabValues, tabs, ts, windowRemovedListener, windows,
    hasProp = {}.hasOwnProperty;

  require("./shoulda.js");

  _ = require("./underscore-min.js");

  global.extend = function(hash1, hash2) {
    var key;
    for (key in hash2) {
      hash1[key] = hash2[key];
    }
    hash1;
    return extend(global, require("./chromeStubs.js"));
  };

  TabShepherd = require("./TabShepherd.js").TabShepherd;

  inputChanged = null;

  inputEntered = null;

  windowRemovedListener = null;

  activeTabId = null;

  windows = null;

  focusedWindowId = 1;

  tabs = null;

  defs = null;

  omniboxText = null;

  alertText = null;

  ts = null;

  chrome = null;

  tabValues = function() {
    return _.values(tabs);
  };

  suggest = function(text) {
    return omniboxText = text[0].description;
  };

  alert = function(text) {
    return alertText = text;
  };

  randomId = function() {
    return Math.floor(Math.random() * 10000);
  };

  reset = function() {
    tabs = {};
    defs = {};
    focusedWindowId = 1;
    windows = {
      1: {
        tabs: []
      }
    };
    chrome = {
      runtime: {
        lastError: null
      },
      storage: {
        local: {
          get: function(name, cb) {
            var res;
            res = {};
            if (name === 'windowDefs') {
              res[name] = defs;
            }
            return cb(res);
          },
          set: function(newDefs, cb) {
            defs = newDefs['windowDefs'];
            return cb();
          }
        }
      },
      omnibox: {
        onInputChanged: {
          addListener: function(listener) {
            return inputChanged = listener;
          }
        },
        onInputEntered: {
          addListener: function(listener) {
            return inputEntered = listener;
          }
        }
      },
      windows: {
        onRemoved: {
          addListener: function(listener) {
            return windowRemovedListener = listener;
          }
        },
        getCurrent: function(o, cb) {
          if ((focusedWindowId == null) || (windows[focusedWindowId] == null)) {
            throw 'No current window defined';
          }
          return cb(windows[focusedWindowId]);
        },
        create: function(ops, cb) {
          var id, tab, win;
          id = {
            id: randomId()
          };
          tab = {
            url: '',
            id: randomId(),
            windowId: id
          };
          win = {
            id: id,
            tabs: [tab]
          };
          windows[id] = win;
          focusedWindowId = id;
          return cb(win);
        },
        get: function(id, ops, cb) {
          return cb(windows[id]);
        },
        getAll: function(ops, cb) {
          var k, v;
          return cb((function() {
            var results;
            results = [];
            for (k in windows) {
              if (!hasProp.call(windows, k)) continue;
              v = windows[k];
              results.push(v);
            }
            return results;
          })());
        },
        update: function(winId, ops, cb) {
          if (ops != null ? ops.focused : void 0) {
            focusedWindowId = winId;
          }
          return cb();
        }
      },
      tabs: {
        create: function(winId, url, cb) {
          var tab, tabId;
          tabId = randomId();
          tab = {
            url: url,
            id: randomId(),
            windowId: winId
          };
          tabs[tabId] = tab;
          windows[winId].tabs.push(tab);
          return cb(tab);
        },
        query: function(ops, cb) {
          var fits, t;
          fits = function(t) {
            return (!ops.currentWindow || t.windowId === focusedWindowId) && (!ops.active || t.id === activeTabId);
          };
          return cb((function() {
            var i, len, ref, results;
            ref = tabValues();
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              t = ref[i];
              if (fits(t)) {
                results.push(t);
              }
            }
            return results;
          })());
        },
        get: function(id, cb) {
          return cb(tabs[id]);
        },
        getAllInWindow: function(winId, cb) {
          return cb(_.filter(tabValues(), function(t) {
            return t.windowId === winId;
          }));
        },
        update: function(id, ops, cb) {
          var k, tab, v;
          tab = tabs[id];
          for (k in ops) {
            if (!hasProp.call(ops, k)) continue;
            v = ops[k];
            tab[k] = v;
          }
          return cb(tab);
        },
        move: function(ids, ops, cb) {
          var i, id, idx, len, newWin, results, tab, win;
          newWin = windows[ops.windowId];
          results = [];
          for (i = 0, len = ids.length; i < len; i++) {
            id = ids[i];
            win = windows[tab.windowId];
            idx = _.findIndexOf(win.tabs, function(t) {
              return t.id === id;
            });
            win.tabs.splice(idx, 1);
            tab = tabs[id];
            newWin.tabs.push(tab);
            results.push(cb(tab));
          }
          return results;
        },
        remove: function(id, cb) {
          var idx, tab, win;
          tab = tabs[id];
          win = windows[tab.windowId];
          idx = _.findIndexOf(win.tabs, function(t) {
            return t.id === id;
          });
          win.tabs.splice(idx, 1);
          delete tabs[id];
          return cb();
        }
      }
    };
    return ts = new TabShepherd(chrome, alert);
  };

  changeInput = function(input) {
    return inputChanged(input, suggest);
  };

  enterInput = function(input) {
    return inputEntered(input);
  };

  assertOmni = function(text) {
    return assertText(text, omniboxText);
  };

  assertAlert = function(text) {
    return assertText(text, alertText);
  };

  assertNoOutput = function() {
    return assert.isTrue(omniboxText === null && alertText === null);
  };

  assertText = function(text, holder) {
    var out;
    out = (function() {
      if (typeof text === 'object' && typeof text.test === 'function') {
        return assert.isTrue(new RegExp(text).test(holder));
      } else if (typeof text === 'string') {
        return assert.equal(text, holder);
      } else {
        throw "Can't test a text of type " + (typeof text) + ".";
      }
    })();
    omniboxText = null;
    alertText = null;
    return out;
  };

  expectSuggestionFor = function(text, output) {
    changeInput(text);
    return assertOmni(output);
  };

  expectResponseFor = function(text, output) {
    enterInput(text);
    return assertAlert(output);
  };

  expectNoResponseFor = function(text) {
    enterInput(text);
    return assertNoOutput();
  };

  context("Commands", should("initialize", function() {
    assert.equal('function', typeof TabShepherd);
    assert.equal('object', typeof ts);
    assert.isTrue(inputChanged != null);
    return assert.isTrue(inputEntered != null);
  }));

  context("Commands", should("show help", function() {
    changeInput('help', suggest);
    return assertOmni(/^Possible commands:/);
  }));

  context("Commands", should("show help on a command", function() {
    var cmd, name, ref, results;
    ref = ts.commands();
    results = [];
    for (name in ref) {
      if (!hasProp.call(ref, name)) continue;
      cmd = ref[name];
      changeInput("help " + name, suggest);
      if ((cmd.alias == null) && name !== 'help') {
        results.push(assertOmni(name + ": " + cmd.desc));
      } else {
        results.push(void 0);
      }
    }
    return results;
  }));

  context("name", should("handle command", function() {
    reset();
    expectSuggestionFor('name', 'Enter a name for this window.');
    expectResponseFor('name', 'No name provided.');
    expectSuggestionFor('name foo', "Press enter to name this window 'foo'.");
    expectNoResponseFor('name foo');
    assert.equal('foo', windows[focusedWindowId].name);
    assert.isTrue(defs['foo'] != null);
    assert.equal('foo', defs['foo'].name);
    expectSuggestionFor('name ', "Enter a new name for this window (currently named 'foo').");
    expectSuggestionFor('name blah', "Press enter to change window name from 'foo' to 'blah'.");
    enterInput('name blah');
    assert.equal('blah', windows[focusedWindowId].name);
    assert.isTrue(defs['blah'] != null);
    assert.isFalse(defs['foo'] != null);
    return assert.equal('blah', defs['blah'].name);
  }));

  context("defs", should("handle command", function() {
    reset();
    expectSuggestionFor('defs', 'Press enter to list the window definitions.');
    expectResponseFor('defs', 'Named windows:\n\n');
    enterInput('name hi');
    return expectResponseFor('defs', /^Named windows:\s+hi/);
  }));

  context("new", should("handle command", function() {
    reset();
    expectSuggestionFor('new', 'Enter a name for the new window.');
    expectSuggestionFor('new yes', "Press enter to open a new window and name it 'yes'.");
    expectSuggestionFor('new yes okay', "Press enter to open a new window named 'yes' and assign it the pattern 'okay'.");
    expectSuggestionFor('new yes hello|goodbye', "Press enter to open a new window named 'yes' and assign it the pattern /hello|goodbye/.");
    expectNoResponseFor('new yes okay');
    assert.equal('yes', windows[focusedWindowId].name);
    assert.isTrue(defs['yes'] != null);
    assert.equal('yes', defs['yes'].name);
    assert.equal(['okay'], defs['yes'].patterns);
    return expectSuggestionFor('new yes', "There is already a window named 'yes'.");
  }));

  Tests.run();

}).call(this);
