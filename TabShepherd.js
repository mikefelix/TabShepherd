// Generated by CoffeeScript 1.9.1
(function() {
  var TabShepherd, root,
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  TabShepherd = (function() {
    var Command, alert, assignPattern, commands, containsPattern, definitions, deleteDefinition, focus, getArgs, getCommand, getDefForPattern, getDefinition, getId, getName, isRegex, listPatterns, loadDefinitions, makeText, omnibox, plur, runtime, setName, showExamples, storage, storeDefinitions, summarizeCommands, tabs, unassignPattern, windows, withActiveTab, withCurrentWindow, withEachDefinition, withEachWindow, withHighlightedTab, withNewWindow, withTabsMatching, withWindow, withWindowForPattern, withWindowNamed;

    storage = null;

    omnibox = null;

    windows = null;

    tabs = null;

    runtime = null;

    definitions = null;

    alert = null;

    function TabShepherd(chrome, _alert) {
      storage = chrome.storage.local;
      omnibox = chrome.omnibox;
      windows = chrome.windows;
      tabs = chrome.tabs;
      runtime = chrome.runtime;
      alert = _alert;
      storage.get('windowDefs', (function(_this) {
        return function(data) {
          return definitions = data['windowDefs'] || {};
        };
      })(this));
      omnibox.onInputChanged.addListener((function(_this) {
        return function(text, suggest) {
          var c;
          c = new Command(text, function(res) {
            if (res) {
              return suggest([
                {
                  content: ' ',
                  description: res
                }
              ]);
            }
          });
          return c.help();
        };
      })(this));
      omnibox.onInputEntered.addListener((function(_this) {
        return function(text) {
          var c;
          c = new Command(text, function(res) {
            if (res) {
              return alert(res);
            }
          });
          return c.run();
        };
      })(this));
      windows.onRemoved.addListener((function(_this) {
        return function(windowId) {
          return withWindow(windowId, function(win) {
            var def;
            if ((getName(win) != null)) {
              def = getDefinition(win);
              return withHighlightedTab(win, function(tabs) {
                if (tabs.length > 0) {
                  def.activeUrl = tabs[0].url;
                }
                return storeDefinitions();
              });
            }
          });
        };
      })(this));
    }

    TabShepherd.prototype.commands = function() {
      return commands;
    };

    getCommand = function(text) {
      var idx, name;
      idx = text ? text.indexOf(' ') : -1;
      name = idx === -1 ? text : text.substring(0, idx);
      if (commands[name]) {
        if (commands[name]['alias']) {
          return commands[commands[name]['alias']];
        } else {
          return commands[name];
        }
      } else {
        return commands['help'];
      }
    };

    getArgs = function(text) {
      text = text.trim();
      if (!/^\S+\s+\S+/.test(text)) {
        return [];
      }
      return text.replace(/^\S+\s+/, '').split(/\s+/);
    };

    TabShepherd.prototype.makeText = function() {
      var a;
      return makeText.apply(null, (function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = arguments.length; j < len; j++) {
          a = arguments[j];
          results1.push(a);
        }
        return results1;
      }).apply(this, arguments));
    };

    makeText = function() {
      var a, arg, arr, j, len, m, matches, msg, v;
      arr = (function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = arguments.length; j < len; j++) {
          a = arguments[j];
          results1.push(a);
        }
        return results1;
      }).apply(this, arguments);
      if (arr.length === 0) {
        return void 0;
      }
      msg = arr.shift();
      if (arr.length === 0) {
        return msg;
      }
      matches = msg.match(/(%[spw])/g);
      if (matches == null) {
        return msg;
      }
      for (j = 0, len = matches.length; j < len; j++) {
        m = matches[j];
        arg = arr.shift();
        v = (function() {
          switch (m) {
            case '%p':
              if (isRegex(arg)) {
                return "/" + arg + "/";
              } else {
                return "'" + arg + "'";
              }
              break;
            case '%w':
              if (arg) {
                return "\"" + arg + "\"";
              } else {
                return '(unnamed)';
              }
              break;
            default:
              return arg;
          }
        })();
        msg = msg.replace(m, v != null ? v : '');
      }
      return msg;
    };

    isRegex = function(arg) {
      return /[*+|()$^?\[\]{}]/.test(arg);
    };

    getId = function(win) {
      if (typeof win === 'number') {
        return win;
      } else if (typeof win === 'object') {
        return win.id;
      } else {
        return alert("Can't find id from " + typeof win);
      }
    };

    showExamples = function(cmd) {
      var command, ex, examples, msg;
      if (commands[cmd] == null) {
        return '';
      }
      msg = '"' + cmd + '": ' + commands[cmd].desc + '.\n\nExamples:\n\n';
      command = commands[cmd];
      examples = command.examples;
      for (ex in examples) {
        msg += ex + "\n  " + examples[ex] + "\n\n";
      }
      return msg;
    };

    summarizeCommands = function(full) {
      var cmd, j, len, msg, name, type, types;
      if (full && full !== true) {
        return showExamples(full);
      }
      msg = '';
      if (full) {
        msg += 'Syntax: ts <command> <arguments>\n\n';
      }
      msg += 'Possible commands:' + (full ? '\n' : ' ');
      types = ['Moving tabs', 'Changing focus', 'Managing window definitions', 'Managing URL patterns', 'Help'];
      for (j = 0, len = types.length; j < len; j++) {
        type = types[j];
        if (full) {
          msg += "  " + type + ":\n";
        }
        for (name in commands) {
          if (!hasProp.call(commands, name)) continue;
          cmd = commands[name];
          if (cmd.type === type) {
            if (full) {
              msg += "    " + name + ": " + cmd.desc + ".\n";
            } else {
              msg += name + ' ';
            }
          }
        }
      }
      return msg;
    };

    focus = function(win) {
      return windows.update(win.id, {
        focused: true
      }, function() {});
    };

    deleteDefinition = function(name) {
      return delete definitions[name];
    };

    TabShepherd.prototype.getDefinition = function(name) {
      return getDefinition(name);
    };

    getDefinition = function(nameOrWin) {
      var def, name;
      if (typeof nameOrWin === 'string') {
        return definitions[nameOrWin];
      } else if (nameOrWin.id != null) {
        for (name in definitions) {
          if (!hasProp.call(definitions, name)) continue;
          def = definitions[name];
          if (def.id === nameOrWin.id) {
            return def;
          }
        }
      }
    };

    TabShepherd.prototype.storeDefinitions = function() {
      return storeDefinitions();
    };

    storeDefinitions = function() {
      return storage.set({
        windowDefs: definitions
      }, function() {
        if (runtime.lastError) {
          return alert(runtime.lastError);
        }
      });
    };

    loadDefinitions = function(callback) {
      return storage.get('windowDefs', function(data) {
        definitions = data['windowDefs'] || {};
        return callback();
      });
    };

    TabShepherd.prototype.setName = function(win, name) {
      return setName(win, name);
    };

    setName = function(win, name) {
      var currName;
      currName = getName(win);
      if (name === currName) {
        return;
      }
      if ((currName != null) && (definitions[currName] != null)) {
        if (currName !== name) {
          definitions[name] = definitions[currName];
          delete definitions[currName];
        }
      } else {
        definitions[name] = {
          id: win.id
        };
      }
      return definitions[name].name = name;
    };

    TabShepherd.prototype.getName = function(win) {
      return getName(win);
    };

    getName = function(win) {
      var id, name;
      id = getId(win);
      for (name in definitions) {
        if (!hasProp.call(definitions, name)) continue;
        if (definitions[name].id === id) {
          return name;
        }
      }
    };

    getDefForPattern = function(pattern) {
      var def, j, len, name, ref;
      for (name in definitions) {
        if (!hasProp.call(definitions, name)) continue;
        def = definitions[name];
        if (def.patterns) {
          ref = def.patterns;
          for (j = 0, len = ref.length; j < len; j++) {
            pattern = ref[j];
            if (pattern === def.patterns[i]) {
              return def;
            }
          }
        }
      }
    };

    TabShepherd.prototype.assignPattern = function(pattern, win) {
      return assignPattern(pattern, win);
    };

    assignPattern = function(pattern, win) {
      var def, name;
      name = getName(win);
      if (name == null) {
        alert('Window has no name!');
        return false;
      }
      if (definitions[name] == null) {
        alert("Window " + name + " has no definition!");
        return false;
      }
      def = definitions[name];
      if (def.patterns == null) {
        def.patterns = [];
      }
      def.patterns.push(pattern);
      return true;
    };

    unassignPattern = function(pattern, window) {
      var def, i;
      if (window.name == null) {
        alert('Window has no name.');
        return false;
      }
      def = definitions[window.name];
      if (def == null) {
        alert('No definition found for name ' + window.name);
        return false;
      }
      if (def.patterns == null) {
        alert('No patterns found in window ' + window.name);
        return false;
      }
      i = 0;
      while (i < def.patterns.length) {
        if (def.patterns[i] === pattern) {
          def.patterns.splice(i, 1);
          return true;
        }
        i++;
      }
      alert("Could not delete pattern " + pattern + " from window '" + window.name + "'.");
      return false;
    };

    containsPattern = function(pattern) {
      var j, len, regex, regexes;
      if (!definitions[window.name]) {
        alert('Unknown window ' + window.name);
      }
      regexes = definitions[window.name].regexes;
      if (!regexes) {
        return false;
      }
      for (j = 0, len = regexes.length; j < len; j++) {
        regex = regexes[j];
        if (regex === pattern) {
          return true;
        }
      }
      return false;
    };

    listPatterns = function(window) {
      var def, j, len, patt, patterns, results1;
      def = definitions[window.name];
      if (!def) {
        return '';
      }
      patterns = def.patterns || [];
      results1 = [];
      for (j = 0, len = patterns.length; j < len; j++) {
        patt = patterns[j];
        results1.push("/" + patt + "/\n");
      }
      return results1;
    };

    withWindowForPattern = function(pattern, callback) {
      var def;
      def = getDefForPattern(pattern);
      if (def == null) {
        return callback();
      }
      if (def.id == null) {
        return alert("Definition " + def + " found for pattern " + pattern + " but it has no assigned window.");
      } else {
        return windows.get(def.id, {}, (function(_this) {
          return function(w) {
            w.def = def;
            return callback(w);
          };
        })(this));
      }
    };

    withTabsMatching = function(patterns, callback) {
      var matches;
      if (!patterns) {
        return callback([]);
      }
      if (typeof patterns === 'string') {
        patterns = [patterns];
      }
      if (patterns.length === 0 || patterns[0] === '') {
        return callback([]);
      }
      matches = (function(_this) {
        return function(tab) {
          var j, len, p, r;
          for (j = 0, len = patterns.length; j < len; j++) {
            p = patterns[j];
            if (/^\/.+\/$/.test(p)) {
              r = new RegExp(p.substring(1, p.length - 1));
              if (r.test(tab.url) || r.test(tab.title)) {
                return true;
              }
            } else if (isRegex(p)) {
              r = new RegExp(p);
              if (r.test(tab.url) || r.test(tab.title)) {
                return true;
              }
            } else {
              if (tab.url.toLowerCase().search(p) > -1 || tab.title.toLowerCase().search(p) > -1) {
                return true;
              }
            }
          }
          return false;
        };
      })(this);
      return tabs.query({
        status: 'complete',
        windowType: 'normal'
      }, (function(_this) {
        return function(results) {
          var tab;
          return callback((function() {
            var j, len, results1;
            results1 = [];
            for (j = 0, len = results.length; j < len; j++) {
              tab = results[j];
              if (matches(tab)) {
                results1.push(tab.id);
              }
            }
            return results1;
          })());
        };
      })(this));
    };

    withEachWindow = function(args) {
      var action, condition, finish, reduce;
      condition = args.where || (function(_this) {
        return function() {
          return true;
        };
      })(this);
      action = args.run;
      finish = args.then;
      reduce = args.reduce || (function(_this) {
        return function(msgs) {
          return msgs.join(',');
        };
      })(this);
      return windows.getAll({}, (function(_this) {
        return function(wins) {
          var def, j, len, msgs, win;
          msgs = [];
          for (j = 0, len = wins.length; j < len; j++) {
            win = wins[j];
            def = definitions[win];
            if (condition(win, def)) {
              msgs.push(action(win, def));
            }
          }
          if (finish != null) {
            return finish(reduce(msgs));
          }
        };
      })(this));
    };

    withWindow = function(arg, callback) {
      var where;
      where = typeof arg === 'string' ? (function(_this) {
        return function(win) {
          return getName(win) === arg;
        };
      })(this) : typeof arg === 'number' ? (function(_this) {
        return function(win) {
          return win.id === arg;
        };
      })(this) : typeof arg === 'function' ? arg : typeof arg === 'object' ? (function(_this) {
        return function(win) {
          var all, k, v;
          all = (function() {
            var results1;
            results1 = [];
            for (k in arg) {
              if (!hasProp.call(arg, k)) continue;
              v = arg[k];
              results1.push(win[k] === v);
            }
            return results1;
          })();
          return all.reduce(function(t, s) {
            return t && s;
          });
        };
      })(this) : (alert("Can't use this argument type."), void 0);
      if (where) {
        return withEachWindow({
          where: where,
          run: callback
        });
      }
    };

    withEachDefinition = function(args) {
      var action, condition, finish, reduce;
      condition = args.where || function() {
        return true;
      };
      action = args.run;
      finish = args.then;
      reduce = args.reduce || function(msgs) {
        return msgs.join(',');
      };
      return windows.getAll({}, function(wins) {
        var def, findWin, msgs, name, win;
        findWin = function(name) {
          var j, len, win;
          for (j = 0, len = wins.length; j < len; j++) {
            win = wins[j];
            if (getName(win) === name) {
              return win;
            }
          }
        };
        msgs = [];
        for (name in definitions) {
          if (!hasProp.call(definitions, name)) continue;
          def = definitions[name];
          win = findWin(name);
          if (condition(def, win)) {
            msgs.push(action(def, win));
          }
        }
        if (finish != null) {
          return finish(reduce(msgs));
        }
      });
    };

    withActiveTab = function(callback) {
      return tabs.query({
        active: true,
        currentWindow: true
      }, function(tabs) {
        return callback(tabs[0]);
      });
    };

    withNewWindow = function(name, callback) {
      return windows.create({
        type: 'normal'
      }, function(win) {
        definitions[name] = {
          id: win.id,
          name: name
        };
        setName(win, name);
        return callback(win);
      });
    };

    TabShepherd.prototype.withCurrentWindow = function(callback) {
      return withCurrentWindow(callback);
    };

    withCurrentWindow = function(callback) {
      return windows.getCurrent({}, function(win) {
        return callback(win);
      });
    };

    withWindowNamed = function(name, callback) {
      return windows.getAll({}, function(wins) {
        var j, len, win;
        for (j = 0, len = wins.length; j < len; j++) {
          win = wins[j];
          if (getName(win) === name) {
            return callback(win);
          }
        }
        return callback(void 0);
      });
    };

    withHighlightedTab = function(win, callback) {
      return tabs.query({
        active: true,
        windowId: win.id
      }, function(tabs) {
        if (tabs.length > 0) {
          return callback(tabs[0]);
        }
      });
    };

    plur = function(word, num) {
      var text;
      text = num === 1 ? word : /y$/.test(word) ? word.slice(0) + 'ies' : /s$/.test(word) ? word + 'es' : word + 's';
      return num + " " + text;
    };

    Command = (function() {
      var close, cmd, output, saveData;

      saveData = null;

      output = null;

      cmd = null;

      function Command(text, _output) {
        cmd = getCommand(text);
        this.args = getArgs(text);
        output = _output;
      }

      close = function() {
        return storeDefinitions();
      };

      Command.prototype.exec = function(f) {
        return loadDefinitions((function(_this) {
          return function() {
            return f.apply(_this, _this.args);
          };
        })(this));
      };

      Command.prototype.finish = function() {
        var a, args, status;
        args = (function() {
          var j, len, results1;
          results1 = [];
          for (j = 0, len = arguments.length; j < len; j++) {
            a = arguments[j];
            results1.push(a);
          }
          return results1;
        }).apply(this, arguments);
        status = makeText.apply(null, args);
        output(status);
        if (saveData) {
          return close();
        }
      };

      Command.prototype.run = function() {
        saveData = true;
        return this.exec(cmd.run);
      };

      Command.prototype.help = function() {
        saveData = false;
        return this.exec(cmd.help);
      };

      return Command;

    })();

    TabShepherd.prototype.commands = function() {
      return commands;
    };

    commands = {
      tabs: {
        desc: "Show active tab information",
        type: 'Managing window definitions',
        examples: {
          "ts tabs": "Show active tab information."
        },
        help: function() {
          return this.finish("Press enter to see active tab information.");
        },
        run: function() {
          return tabs.query({
            active: true
          }, (function(_this) {
            return function(t) {
              var tab;
              return _this.finish(((function() {
                var j, len, results1;
                results1 = [];
                for (j = 0, len = t.length; j < len; j++) {
                  tab = t[j];
                  results1.push(tab.windowId + ": " + tab.url);
                }
                return results1;
              })()).join("\n"));
            };
          })(this));
        }
      },
      wins: {
        desc: "Show window information",
        type: 'Managing window definitions',
        examples: {
          "ts tabs": "Show window information."
        },
        help: function() {
          return this.finish("Press enter to see window information.");
        },
        run: function() {
          return windows.getAll((function(_this) {
            return function(wins) {
              var win;
              return _this.finish(((function() {
                var j, len, results1;
                results1 = [];
                for (j = 0, len = wins.length; j < len; j++) {
                  win = wins[j];
                  results1.push(win.id + ": " + (getName(win)));
                }
                return results1;
              })()).join("\n"));
            };
          })(this));
        }
      },
      id: {
        desc: "Show the current window's ID",
        type: 'Managing window definitions',
        examples: {
          "ts id": "Show the current window's ID."
        },
        help: function() {
          return withCurrentWindow((function(_this) {
            return function(win) {
              return _this.finish("This window's ID is %s and its name is %w", win.id, getName(win));
            };
          })(this));
        },
        run: function() {}
      },
      n: {
        alias: 'name'
      },
      name: {
        desc: 'Change the name of the current window definition',
        type: 'Managing window definitions',
        examples: {
          'ts name awesome': "Create a definition for the current window named 'awesome'."
        },
        help: function(newName) {
          return withCurrentWindow((function(_this) {
            return function(win) {
              if (getName(win) != null) {
                if (newName != null) {
                  return _this.finish("Press enter to change window name from %w to %w.", getName(win), newName);
                } else {
                  return _this.finish("Enter a new name for this window (currently named %w).", getName(win));
                }
              } else {
                if (newName != null) {
                  return _this.finish("Press enter to name this window %w.", newName);
                } else {
                  return _this.finish('Enter a name for this window.');
                }
              }
            };
          })(this));
        },
        run: function(name) {
          if (!name) {
            return this.finish('No name provided.');
          }
          return withCurrentWindow((function(_this) {
            return function(win) {
              setName(win, name);
              return _this.finish();
            };
          })(this));
        }
      },
      attach: {
        desc: 'Attach the current window to a previously defined window definition',
        type: 'Managing window definitions',
        examples: {
          'ts attach work': 'Attach the current window to the existing window definition called \'work\'.'
        },
        help: function() {
          return withCurrentWindow((function(_this) {
            return function(win) {};
          })(this));
        },
        run: function() {
          return withCurrentWindow((function(_this) {
            return function(win) {};
          })(this));
        }
      },
      defs: {
        desc: 'List named window definitions',
        type: 'Managing window definitions',
        examples: {
          'ts defs': 'List all the window definitions that exist.'
        },
        help: function() {
          return this.finish('Press enter to list the window definitions.');
        },
        run: function() {
          console.dir(definitions);
          return withEachDefinition({
            run: (function(_this) {
              return function(def, win) {
                var winText;
                winText = win != null ? 'window ' + win.id : 'no attached window';
                return def.name + " (" + winText + ")";
              };
            })(this),
            reduce: (function(_this) {
              return function(msgs) {
                return msgs.join("\n");
              };
            })(this),
            then: (function(_this) {
              return function(text) {
                return _this.finish('Named windows:\n\n%s', text);
              };
            })(this)
          });
        }
      },
      "new": {
        desc: 'Create a new empty window and assign it a definition',
        type: 'Managing window definitions',
        examples: {
          'ts new cats': "Create a new window with definition named 'cats'.",
          'ts new cats \\bcats?\\b': "Create a new window with definition named 'cats' and containing one pattern. Move no tabs."
        },
        help: function(name) {
          if (!name) {
            return this.finish('Enter a name for the new window.');
          }
          return withWindowNamed(name, (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish("There is already a window named %w.", name);
              } else if (_this.args.length === 1) {
                return _this.finish("Press enter to open a new window and name it %w.", name);
              } else if (_this.args.length === 2) {
                return _this.finish("Press enter to open a new window named %w and assign it the pattern %p.", name, _this.args[1]);
              } else {
                return _this.finish("Press enter to open a new window named %w and assign it the patterns.", name);
              }
            };
          })(this));
        },
        run: function(name) {
          if (!name) {
            return this.finish('No window name provided.');
          }
          return withWindowNamed(name, (function(_this) {
            return function(win) {
              if (win) {
                return _this.finish("There is already a window named %w.", name);
              }
              return withNewWindow(name, function(win) {
                var arg, def, j, len, ref;
                def = getDefinition(name);
                ref = _this.args.slice(1);
                for (j = 0, len = ref.length; j < len; j++) {
                  arg = ref[j];
                  if (win.patterns == null) {
                    def.patterns = [];
                  }
                  def.patterns.push(arg);
                }
                return _this.finish();
              });
            };
          })(this));
        }
      },
      clear: {
        desc: 'Clear window definitions',
        type: 'Managing window definitions',
        examples: {
          'ts clear recipes': "Remove the window definition 'recipes'. No tabs are affected.",
          'ts clear *': "Remove all window definitions from storage. No tabs are affected."
        },
        help: function(name) {
          if (name == null) {
            return this.finish('Enter a window definition name');
          }
          if (name === '*') {
            return this.finish('Press enter to clear all saved window definitions.');
          }
          return withWindowNamed(name, (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish("Press enter to clear window definition %w. Warning: currently assigned to a window.", name);
              } else if (getDefinition(name) != null) {
                return _this.finish("Press enter to clear window definition %w, not currently assigned to a window.", name);
              } else {
                return _this.finish("Window definition %w not found.", name);
              }
            };
          })(this));
        },
        run: function(name) {
          var def;
          if (name == null) {
            return this.finish('Enter a window definition name');
          }
          if (name === '*') {
            for (name in definitions) {
              if (!hasProp.call(definitions, name)) continue;
              def = definitions[name];
              deleteDefinition(name);
            }
            return this.finish('Cleared all window definitions.');
          } else {
            return withWindowNamed(name, (function(_this) {
              return function(win) {
                if (win != null) {
                  deleteDefinition(name);
                  return _this.finish("Cleared window definition %w and removed it from a window.", name);
                } else if (getDefinition(name) != null) {
                  deleteDefinition(name);
                  return _this.finish("Cleared window definition %w.", name);
                } else {
                  return _this.finish("Window definition %w not found.", name);
                }
              };
            })(this));
          }
        }
      },
      clean: {
        desc: 'Clean window data, removing definitions for which no window is present',
        type: 'Managing window definitions',
        examples: {
          'ts clean': 'Clean window data, removing definitions for which no window is present. No tabs are affected.'
        },
        help: function() {
          return withEachDefinition({
            where: function(def, win) {
              return !win;
            },
            run: function(def, win, name) {
              return "'" + name + "'";
            },
            then: function(msg) {
              return this.finish(msg ? 'Press enter to clean unused window definitions: ' + msg : 'No window definitions need cleaning.');
            }
          });
        },
        run: function() {
          return withEachDefinition({
            where: function(def, win) {
              return !win;
            },
            run: (function(_this) {
              return function(def, win, name) {
                deleteDefinition(name);
                return "'" + name + "'";
              };
            })(this),
            then: function(msg) {
              return this.finish(msg ? 'Cleaned unused window definitions: ' + msg : 'No window definitions needed cleaning.');
            }
          });
        }
      },
      unnamed: {
        desc: 'Go to a window having no definition',
        type: 'Managing window definitions',
        examples: {
          'ts unnamed': 'Find a window with no definition if such exists, and focus it; else do nothing.'
        },
        help: function() {
          return withWindow((function(win) {
            return getName(win) == null;
          }), (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish('Press enter to go to an open window that has no definition.');
              } else {
                return _this.finish('All windows have a definition.');
              }
            };
          })(this));
        },
        run: function() {
          return withWindow((function(win) {
            return getName(win) == null;
          }), (function(_this) {
            return function(win) {
              if (win) {
                focus(win);
              }
              return _this.finish();
            };
          })(this));
        }
      },
      focus: {
        desc: 'Switch to the window with the given name',
        type: 'Changing focus',
        examples: {
          'ts focus work': "Focus the window named 'work'."
        },
        help: function(name) {
          if (!getDefinition(name)) {
            return this.finish('Type a defined window name.');
          } else {
            return this.finish("Press enter to focus window %w.", name);
          }
        },
        run: function(name) {
          if (!getDefinition(name)) {
            return this.finish("No such window %w.", name);
          } else {
            return withWindow(name, (function(_this) {
              return function(win) {
                if (win == null) {
                  return _this.finish("Window not found: %w.", name);
                } else {
                  focus(win);
                  return _this.finish();
                }
              };
            })(this));
          }
        }
      },
      go_exp: {
        desc: 'Perform either "find", "extract" or "focus", depending on the arguments',
        type: 'Changing focus',
        examples: {
          'ts go document': 'If there is one tab matching /document/, behave as "ts find document", else behave as "ts extract document".',
          'ts go "work"': 'If there is a window named "work", behave as "ts focus work", otherwise behave as "ts new work".'
        },
        help: function(pattern, name) {
          if (name == null) {
            name = pattern;
          }
          if (/^"/.test(pattern)) {
            return getCommand('focus').help.apply(this, this.args);
          } else {
            return getCommand('find').help.apply(this, this.args);
          }
        },
        run: function(pattern, name) {
          if (name == null) {
            name = pattern;
          }
          if (/^"/.test(pattern)) {
            return getCommand('focus').run.apply(this, this.args);
          } else {
            return getCommand('find').run.apply(this, this.args);
          }
        }
      },
      go: {
        desc: 'Perform either "find", "extract" or "focus", depending on the arguments',
        type: 'Changing focus',
        examples: {
          'ts go document': 'If there is one tab matching /document/, behave as "ts find document", else behave as "ts extract document".',
          'ts go "work"': 'If there is a window named "work", behave as "ts focus work", otherwise behave as "ts new work".'
        },
        help: function(pattern, name) {
          if (name == null) {
            name = pattern;
          }
          if (/^"/.test(pattern)) {
            if (!getDefinition(name)) {
              return this.finish("Press enter to create a new window named %w", name.replace(/"/, ""));
            } else {
              return this.finish("Press enter to focus window %w.", name.replace(/"/, ""));
            }
          } else {
            return withTabsMatching(pattern, (function(_this) {
              return function(matchingTabsIds) {
                if (matchingTabsIds.length === 1) {
                  return _this.finish("Press enter to focus the single tab matching %p.", pattern);
                } else if (matchingTabsIds.length > 1) {
                  return _this.finish("Press enter to extract the %s tabs matching %p into a new window named %w.", matchingTabsIds.length, pattern, name);
                } else {
                  return _this.finish("No tabs found matching %p.", pattern);
                }
              };
            })(this));
          }
        },
        run: function(pattern, name) {
          var win;
          if (name == null) {
            name = pattern;
          }
          if (/^"/.test(pattern)) {
            win = pattern.replace(/"/, "");
            if (!getDefinition(name)) {
              return withNewWindow(name, (function(_this) {
                return function() {
                  return _this.finish();
                };
              })(this));
            } else {
              return withWindow(name, (function(_this) {
                return function(win) {
                  if (win == null) {
                    _this.finish("Window not found: %w.", name);
                  }
                  focus(win);
                  return _this.finish();
                };
              })(this));
            }
          } else {
            return withTabsMatching(pattern, (function(_this) {
              return function(matchingTabsIds) {
                if (matchingTabsIds.length === 1) {
                  return tabs.get(matchingTabsIds[0], function(tab) {
                    return windows.update(tab.windowId, {
                      focused: true
                    }, function() {
                      return tabs.update(tab.id, {
                        active: true
                      }, function() {});
                    });
                  });
                } else if (matchingTabsIds.length > 1) {
                  return withNewWindow(name, function(win) {
                    return tabs.move(matchingTabsIds, {
                      windowId: win.id,
                      index: -1
                    }, (function(_this) {
                      return function() {
                        setName(win, name);
                        win.patterns = [pattern];
                        return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                          return _this.finish();
                        });
                      };
                    })(this));
                  });
                } else {
                  return _this.finish("No tabs found matching %p.", pattern);
                }
              };
            })(this));
          }
        }
      },
      f: {
        alias: 'find'
      },
      find: {
        desc: 'Go to the first tab found matching a pattern.',
        type: 'Changing focus',
        examples: "ts find google.com': 'Focus the first tab found to match 'google.com'.",
        help: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to find a tab.');
          }
          return withTabsMatching(pattern, (function(_this) {
            return function(matchingTabs) {
              if (matchingTabs.length > 1) {
                return _this.finish("Press enter to focus the first of %s tabs matching %p.", matchingTabs.length, pattern);
              } else if (matchingTabs.length === 1) {
                return tabs.get(matchingTabs[0], function(tab) {
                  return windows.get(tab.windowId, {}, function(win) {
                    var name;
                    name = getName(win);
                    if (name != null) {
                      return _this.finish('Press enter to focus the tab matching %p in window %w.', pattern, name);
                    } else {
                      return _this.finish('Press enter to focus the tab matching %p.', pattern);
                    }
                  });
                });
              } else {
                return _this.finish('No matching tabs found for %p.', pattern);
              }
            };
          })(this));
        },
        run: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to find a tab.');
          }
          return withTabsMatching(pattern, (function(_this) {
            return function(matchingTabs) {
              if (matchingTabs.length >= 1) {
                return tabs.get(matchingTabs[0], function(tab) {
                  return windows.update(tab.windowId, {
                    focused: true
                  }, function() {
                    return tabs.update(tab.id, {
                      active: true
                    }, function() {});
                  });
                });
              } else {
                return _this.finish("No matching tabs found for %p.", pattern);
              }
            };
          })(this));
        }
      },
      b: {
        alias: 'bring'
      },
      bring: {
        desc: 'Bring tabs matching a pattern to the current window',
        type: 'Moving tabs',
        examples: {
          'ts bring cute.*bunnies.com': 'Bring tabs whose URLs match the given pattern (e.g. cutewhitebunnies.com and cutefluffybunnies.com) to the current window.',
          'ts bring': 'Bring tabs whose URLs match all this window\'s assigned patterns to this window.'
        },
        help: function() {
          var patterns, ref;
          patterns = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          if (!(patterns != null ? patterns.length : void 0) && !(typeof def !== "undefined" && def !== null ? (ref = def.patterns) != null ? ref.length : void 0 : void 0)) {
            return this.finish('Enter one or more patterns. No assigned patterns exist for this window.');
          }
          return withCurrentWindow((function(_this) {
            return function(win) {
              var def, usingAssigned;
              usingAssigned = patterns.length === 0;
              if (usingAssigned) {
                def = getDefinition(win);
                patterns = def.patterns;
              }
              return withTabsMatching(patterns, function(matchingTabs) {
                var extra, num;
                num = matchingTabs.length;
                if (num < 1) {
                  return _this.finish('No tabs found matching %s.', plur('given pattern', patterns.length));
                } else {
                  if (usingAssigned) {
                    extra = ", or enter different patterns";
                  }
                  return _this.finish('Press enter to bring %s matching %s to this window %w%s.', plur('tab', num), plur('pattern', patterns.length), getName(win), extra);
                }
              });
            };
          })(this));
        },
        run: function() {
          var patterns;
          patterns = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return withCurrentWindow((function(_this) {
            return function(win) {
              var def, usingAssigned;
              usingAssigned = patterns.length === 0;
              if (usingAssigned) {
                def = getDefinition(win);
                if (!def || !def.patterns || def.patterns.length === 0) {
                  return _this.finish('No patterns entered and this window has no assigned patterns.');
                }
                patterns = def.patterns;
              }
              return withTabsMatching(patterns, function(matchingTabs) {
                var pat, type;
                if (matchingTabs.length < 1) {
                  type = usingAssigned ? 'assigned pattern' : 'given pattern';
                  return _this.finish('No tabs found matching %s:\n\n%s', plur(type, patterns.length), ((function() {
                    var j, len, results1;
                    results1 = [];
                    for (j = 0, len = patterns.length; j < len; j++) {
                      pat = patterns[j];
                      results1.push(makeText("%p", pat));
                    }
                    return results1;
                  })()).join("\n"));
                } else {
                  return tabs.move(matchingTabs, {
                    windowId: win.id,
                    index: -1
                  }, function() {
                    return _this.finish();
                  });
                }
              });
            };
          })(this));
        }
      },
      s: {
        alias: 'send'
      },
      send: {
        desc: 'Send the current tab to the window named in the argument',
        type: 'Moving tabs',
        examples: {
          'ts send research': "Send the current tab to the window named 'research'."
        },
        help: function(name) {
          var win;
          if (name == null) {
            return this.finish('Enter a window name to send this tab there.');
          } else {
            win = getDefinition(name);
            return this.finish("Press enter to send this tab to %swindow %w.", (win != null ? '' : 'new '), name);
          }
        },
        run: function(name) {
          return withActiveTab((function(_this) {
            return function(tab) {
              var existingWin;
              existingWin = getDefinition(name);
              if (existingWin != null) {
                return tabs.move(tab.id, {
                  windowId: existingWin.id,
                  index: -1
                });
              } else {
                return withNewWindow(name, function(win) {
                  tabs.move(tab.id, {
                    windowId: win.id,
                    index: -1
                  });
                  return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                    return _this.finish();
                  });
                });
              }
            };
          })(this));
        }
      },
      o: {
        alias: 'open'
      },
      open: {
        desc: 'Open a URL or search in a different window',
        type: 'Moving tabs',
        examples: {
          'ts open work google.com': "Opens the URL 'http://google.com' in the window 'work'."
        },
        help: function(name, url) {
          var win;
          if (!((name != null) && (url != null))) {
            return this.finish('Enter a window name followed by a URL to open the URL there.');
          } else {
            win = getDefinition(name);
            return this.finish("Press enter to open this URL in %swindow %w.", (win ? '' : 'new '), name);
          }
        },
        run: function(name, url) {
          if (!name || !url) {
            return this.finish('Enter a window name followed by a URL.');
          }
          ({
            openTab: (function(_this) {
              return function(win) {
                if (!/^http:\/\//.test(url)) {
                  url = 'http://' + url;
                }
                return tabs.create({
                  windowId: win.id,
                  url: url
                }, function() {
                  return _this.finish();
                });
              };
            })(this)
          });
          return withWindowNamed(name, (function(_this) {
            return function(existingWin) {
              if (existingWin != null) {
                return openTab(existingWin);
              } else {
                return withNewWindow(name, function(win) {
                  return openTab(win);
                });
              }
            };
          })(this));
        }
      },
      e: {
        alias: 'extract'
      },
      ex: {
        alias: 'extract'
      },
      extract: {
        desc: 'Extract tabs matching the pattern argument into a new window named with that pattern',
        type: 'Moving tabs',
        examples: {
          'ts extract social facebook.com twitter.com': "Create a new window, give it a definition named 'social', assign patterns /facebook.com/ and /twitter.com/ to that definition, and move all tabs whose URLs match the patterns there. This is effectively \"ts new social\", followed by \"ts assign facebook.com twitter.com\", then \"ts bring\". "
        },
        help: function() {
          var name, patterns;
          if (this.args.length === 0) {
            return this.finish('Enter a name or pattern.');
          } else {
            name = this.args[0];
            patterns = this.args.length === 1 ? [this.args[0]] : this.args.slice(1);
            return withTabsMatching(patterns, (function(_this) {
              return function(matchingTabs) {
                var num;
                num = matchingTabs.length;
                if (num < 1) {
                  return _this.finish('No tabs found matching %p. Enter more args to use it as a name.', name);
                } else if (patterns.length > 1) {
                  return _this.finish("Press enter to extract %s matching %s patterns into a new window named %w.", plur("tab", num), patterns.length, name);
                } else {
                  return _this.finish("Press enter to extract %s matching %p into a new window named %w.", plur("tab", num), patterns[0], name);
                }
              };
            })(this));
          }
        },
        run: function() {
          var name, patterns;
          if (this.args.length === 0) {
            return this.finish('Enter a name or pattern.');
          } else {
            name = this.args[0];
            patterns = this.args.length === 1 ? [this.args[0]] : this.args.slice(1);
            return withTabsMatching(patterns, (function(_this) {
              return function(matchingTabs) {
                if (matchingTabs.length < 1) {
                  return _this.finish('No tabs found matching the given pattern(s).');
                } else {
                  return withNewWindow(name, function(win) {
                    return tabs.move(matchingTabs, {
                      windowId: win.id,
                      index: -1
                    }, function() {
                      setName(win, name);
                      win.patterns = patterns;
                      return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                        return _this.finish();
                      });
                    });
                  });
                }
              };
            })(this));
          }
        }
      },
      sort: {
        desc: 'Sort all tabs into windows by assigned patterns',
        type: 'Moving tabs',
        examples: {
          'ts sort': "Move all tab that matches a defined pattern to that pattern's window. Effectively, perform \"ts bring\" for each window."
        },
        help: function() {
          return this.finish('Press enter to sort all windows according to their assigned regexes.');
        },
        run: function() {}
      },
      merge: {
        desc: 'Merge all the tabs from a window into this window.',
        type: 'Moving tabs',
        examples: {
          'ts merge restaurants': "Move all the tabs from the window 'restaurants' into the current window and remove the 'restaurants' definition."
        },
        help: function() {},
        run: function() {}
      },
      assign: {
        desc: 'Assign a pattern to the current window',
        type: 'Managing URL patterns',
        examples: {
          'ts assign reddit.com': "Add /reddit.com/ to this window's assigned patterns. No tabs are affected."
        },
        help: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to assign to this window.');
          } else {
            return withWindowForPattern(pattern, (function(_this) {
              return function(currWin) {
                if (currWin != null) {
                  return _this.finish("Press enter to reassign %p to this window from window %w.", pattern, getName(currWin));
                } else {
                  return _this.finish('Press enter to assign %p to this window.', pattern);
                }
              };
            })(this));
          }
        },
        run: function(pattern) {
          if (pattern == null) {
            return this.finish('No pattern provided.');
          } else {
            return withCurrentWindow(function(window) {
              return withWindowForPattern(pattern, function(currWin) {
                var msg;
                msg = void 0;
                if (currWin != null) {
                  if (unassignPattern(pattern, currWin)) {
                    msg = makeText('Pattern %p was moved from window %w to window %w.', pattern, getName(currWin), getName(window));
                  } else {
                    this.finish('Could not unassign pattern %p from window %w.', pattern, getName(currWin));
                  }
                }
                if (assignPattern(pattern, window)) {
                  return this.finish(msg);
                } else {
                  return this.finish('Could not assign pattern %p to window %w.', pattern, getName(window));
                }
              });
            });
          }
        }
      },
      unassign: {
        desc: 'Remove a pattern assignment from the current window',
        type: 'Managing URL patterns',
        examples: {
          'ts unassign reddit.com': 'Remove /reddit.com/ from this window\'s patterns if it is assigned. No tabs are affected.'
        },
        help: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to remove from this window.');
          } else if (!containsPattern(pattern, window)) {
            return this.finish('Pattern %p is not assigned to this window.', pattern);
          } else {
            return this.finish('Press enter to remove %p from this window.', pattern);
          }
        },
        run: function(pattern) {
          if (pattern == null) {
            return this.finish('No pattern provided.');
          } else if (!containsPattern(pattern, window)) {
            return this.finish('Pattern %p is not assigned to this window.');
          } else {
            return withCurrentWindow((function(_this) {
              return function(window) {
                if (unassignPattern(pattern, window)) {
                  return _this.finish();
                } else {
                  return _this.finish('Could not unassign pattern %s from window %w.', pattern, getName(window));
                }
              };
            })(this));
          }
        }
      },
      patterns: {
        desc: 'List patterns assigned to the current window definition',
        type: 'Managing URL patterns',
        examples: {
          'ts patterns': 'List patterns assigned to the current window.'
        },
        help: function() {
          return this.finish('Press enter to list the patterns assigned to this window.');
        },
        run: function() {
          return withCurrentWindow((function(_this) {
            return function(window) {
              return _this.finish("Patterns assigned to window %w:\n\n%s", getName(window), listPatterns(window));
            };
          })(this));
        }
      },
      help: {
        desc: 'Get help on a command',
        type: 'Help',
        examples: {
          'ts help bring': 'Show the usage examples for the "bring" command.'
        },
        help: function(arg) {
          if (!arg || !commands[arg] || arg === 'help') {
            return this.finish(summarizeCommands(false));
          } else {
            return this.finish(arg + ': ' + getCommand(arg).desc);
          }
        },
        run: function(arg) {
          return this.finish(summarizeCommands(arg));
        }
      }
    };

    return TabShepherd;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.TabShepherd = TabShepherd;

}).call(this);
