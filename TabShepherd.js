// Generated by CoffeeScript 1.9.1
(function() {
  var TabShepherd, root,
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  TabShepherd = (function() {
    var Command, alert, assignPattern, commands, containsPattern, definitions, deleteDefinition, focus, getArgs, getCommand, getCommandName, getDefForPattern, getDefinition, getId, getName, getPossibleCommands, isRegex, listPatterns, loadDefinitions, makeText, omnibox, plur, runtime, setName, showExamples, storage, storeDefinitions, summarizeCommands, tabs, unassignPattern, windowMatching, windows, withActiveTab, withCurrentWindow, withEachDefinition, withEachWindow, withExistingWindow, withHighlightedTab, withNewWindow, withTabsMatching, withWindow, withWindowForPattern, withWindowNamed;

    storage = null;

    omnibox = null;

    windows = null;

    tabs = null;

    runtime = null;

    definitions = null;

    alert = null;

    function TabShepherd(chrome, _alert) {
      storage = chrome.storage.local;
      omnibox = chrome.omnibox;
      windows = chrome.windows;
      tabs = chrome.tabs;
      runtime = chrome.runtime;
      alert = _alert;
      storage.get('windowDefs', (function(_this) {
        return function(data) {
          return definitions = data['windowDefs'] || {};
        };
      })(this));
      omnibox.onInputChanged.addListener((function(_this) {
        return function(text, suggest) {
          var c;
          c = new Command(text, function(res) {
            if (res) {
              return suggest([
                {
                  content: ' ',
                  description: res
                }
              ]);
            }
          });
          return c.help();
        };
      })(this));
      omnibox.onInputEntered.addListener((function(_this) {
        return function(text) {
          var output;
          output = getCommandName(text) !== 'help' ? function(res) {
            if (res) {
              return alert(res);
            }
          } : function(url) {
            return withCurrentWindow(function(win) {
              return tabs.create({
                windowId: win.id,
                url: url
              }, function() {});
            });
          };
          return new Command(text, output).run();
        };
      })(this));
    }

    getCommandName = function(text) {
      var idx;
      idx = text ? text.indexOf(' ') : -1;
      if (idx === -1) {
        return text;
      } else {
        return text.substring(0, idx);
      }
    };

    getPossibleCommands = function(text) {
      var k, name, results1, v;
      name = getCommandName(text);
      results1 = [];
      for (k in commands) {
        if (!hasProp.call(commands, k)) continue;
        v = commands[k];
        if (k.indexOf(name) === 0) {
          results1.push(k);
        }
      }
      return results1;
    };

    getCommand = function(text) {
      var cmds;
      cmds = getPossibleCommands(text);
      if (cmds.length === 1) {
        return commands[cmds[0]];
      } else {
        return commands['help'];
      }
    };

    getArgs = function(text) {
      text = text.trim();
      if (!/^\S+\s+\S+/.test(text)) {
        return [];
      }
      return text.replace(/^\S+\s+/, '').split(/\s+/);
    };

    TabShepherd.prototype.makeText = function() {
      var a;
      return makeText.apply(null, (function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = arguments.length; j < len; j++) {
          a = arguments[j];
          results1.push(a);
        }
        return results1;
      }).apply(this, arguments));
    };

    makeText = function() {
      var a, arg, arr, j, len, m, matches, msg, v;
      arr = (function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = arguments.length; j < len; j++) {
          a = arguments[j];
          results1.push(a);
        }
        return results1;
      }).apply(this, arguments);
      if (arr.length === 0) {
        return void 0;
      }
      msg = arr.shift();
      if (arr.length === 0) {
        return msg;
      }
      matches = msg.match(/(%[spw])/g);
      if (matches == null) {
        return msg;
      }
      for (j = 0, len = matches.length; j < len; j++) {
        m = matches[j];
        arg = arr.shift();
        v = (function() {
          switch (m) {
            case '%p':
              if (isRegex(arg)) {
                return "/" + arg + "/";
              } else {
                return "'" + arg + "'";
              }
              break;
            case '%w':
              if (arg) {
                return "\"" + arg + "\"";
              } else {
                return '(unnamed)';
              }
              break;
            default:
              return arg;
          }
        })();
        msg = msg.replace(m, v != null ? v : '');
      }
      return msg;
    };

    isRegex = function(arg) {
      return /[*+|()$^?\[\]{}]/.test(arg);
    };

    getId = function(win) {
      if (typeof win === 'number') {
        return win;
      } else if (typeof win === 'object') {
        return win.id;
      } else {
        return alert("Can't find id from " + typeof win);
      }
    };

    showExamples = function(cmd) {
      var command, ex, examples, msg;
      if (commands[cmd] == null) {
        return '';
      }
      msg = '"' + cmd + '": ' + commands[cmd].desc + '.\n\nExamples:\n\n';
      command = commands[cmd];
      examples = command.examples;
      for (ex in examples) {
        msg += ex + "\n  " + examples[ex] + "\n\n";
      }
      return msg;
    };

    summarizeCommands = function(full) {
      var cmd, j, len, msg, name, type, types;
      if (full && full !== true) {
        return showExamples(full);
      }
      msg = '';
      if (full) {
        msg += 'Syntax: ts <command> <arguments>\n\n';
      }
      msg += 'Possible commands:' + (full ? '\n' : ' ');
      types = ['Moving tabs', 'Changing focus', 'Managing window definitions', 'Managing URL patterns', 'Informational'];
      for (j = 0, len = types.length; j < len; j++) {
        type = types[j];
        if (full) {
          msg += "  " + type + ":\n";
        }
        for (name in commands) {
          if (!hasProp.call(commands, name)) continue;
          cmd = commands[name];
          if (cmd.type === type) {
            if (full) {
              msg += "    " + name + ": " + cmd.desc + ".\n";
            } else {
              msg += name + ' ';
            }
          }
        }
      }
      return msg;
    };

    focus = function(win) {
      return windows.update(win.id, {
        focused: true
      }, function() {});
    };

    deleteDefinition = function(name) {
      return delete definitions[name];
    };

    TabShepherd.prototype.getDefinition = function(name) {
      return getDefinition(name);
    };

    getDefinition = function(nameOrWin) {
      var def, name;
      if (typeof nameOrWin === 'string') {
        return definitions[nameOrWin];
      } else if (nameOrWin.id != null) {
        for (name in definitions) {
          if (!hasProp.call(definitions, name)) continue;
          def = definitions[name];
          if (def.id === nameOrWin.id) {
            return def;
          }
        }
      }
    };

    TabShepherd.prototype.storeDefinitions = function() {
      return storeDefinitions();
    };

    storeDefinitions = function() {
      return tabs.query({
        index: 0
      }, function(tabz) {
        var def, j, len, name, tab;
        for (name in definitions) {
          if (!hasProp.call(definitions, name)) continue;
          def = definitions[name];
          for (j = 0, len = tabz.length; j < len; j++) {
            tab = tabz[j];
            if (tab.windowId === def.id) {
              def.firstUrl = tab.url;
            }
          }
        }
        return storage.set({
          windowDefs: definitions
        }, function() {
          if (runtime.lastError) {
            return alert(runtime.lastError);
          }
        });
      });
    };

    loadDefinitions = function(callback) {
      return storage.get('windowDefs', function(data) {
        definitions = data['windowDefs'] || {};
        withEachDefinition({
          where: function(def, win) {
            return (win == null) && (def.firstUrl != null);
          },
          run: function(def) {
            return tabs.query({
              url: def.firstUrl
            }, function(tabz) {
              if (tabz != null ? tabz.length : void 0) {
                return def.id = tabz[0].windowId;
              }
            });
          }
        });
        return callback();
      });
    };

    TabShepherd.prototype.setName = function(win, name) {
      return setName(win, name);
    };

    setName = function(win, name) {
      var currName;
      currName = getName(win);
      if (name === currName) {
        return;
      }
      if ((currName != null) && (definitions[currName] != null)) {
        if (currName !== name) {
          definitions[name] = definitions[currName];
          delete definitions[currName];
        }
      } else {
        definitions[name] = {
          id: win.id
        };
      }
      return definitions[name].name = name;
    };

    TabShepherd.prototype.getName = function(win) {
      return getName(win);
    };

    getName = function(win) {
      var id, name;
      id = getId(win);
      for (name in definitions) {
        if (!hasProp.call(definitions, name)) continue;
        if (definitions[name].id === id) {
          return name;
        }
      }
    };

    getDefForPattern = function(pattern) {
      var def, j, len, name, ref;
      for (name in definitions) {
        if (!hasProp.call(definitions, name)) continue;
        def = definitions[name];
        if (def.patterns) {
          ref = def.patterns;
          for (j = 0, len = ref.length; j < len; j++) {
            pattern = ref[j];
            if (pattern === def.patterns[i]) {
              return def;
            }
          }
        }
      }
    };

    TabShepherd.prototype.assignPattern = function(win, pattern) {
      return assignPattern(win, pattern);
    };

    assignPattern = function(win, pattern) {
      var def, j, len, name, p, ref;
      name = getName(win);
      if (name == null) {
        alert('Window has no name!');
        return false;
      }
      if (definitions[name] == null) {
        alert("Window " + name + " has no definition!");
        return false;
      }
      def = getDefinition(name);
      if (def.patterns == null) {
        def.patterns = [];
      }
      ref = def.patterns;
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        if (pattern === p) {
          return false;
        }
      }
      def.patterns.push(pattern);
      return true;
    };

    unassignPattern = function(window, pattern) {
      var def, i;
      if (window.name == null) {
        alert('Window has no name.');
        return false;
      }
      def = getDefinition(window);
      if (def == null) {
        alert('No definition found for name ' + window.name);
        return false;
      }
      if (def.patterns == null) {
        alert('No patterns found in window ' + window.name);
        return false;
      }
      i = 0;
      while (i < def.patterns.length) {
        if (def.patterns[i] === pattern) {
          def.patterns.splice(i, 1);
          return true;
        }
        i++;
      }
      alert("Could not delete pattern " + pattern + " from window '" + window.name + "'.");
      return false;
    };

    containsPattern = function(pattern) {
      var j, len, p, patt;
      if (getDefinition(window) == null) {
        alert('Unknown window ' + window.name);
      }
      patt = getDefinitions(window).patterns;
      if (patt == null) {
        return false;
      }
      for (j = 0, len = patt.length; j < len; j++) {
        p = patt[j];
        if (p === pattern) {
          return true;
        }
      }
      return false;
    };

    listPatterns = function(window) {
      var def, patt, patterns, ref;
      def = getDefinition(window);
      if (def == null) {
        return '';
      }
      patterns = (ref = def.patterns) != null ? ref : [];
      return ((function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = patterns.length; j < len; j++) {
          patt = patterns[j];
          results1.push(makeText("%p\n", patt));
        }
        return results1;
      })()).join('');
    };

    withWindowForPattern = function(pattern, callback) {
      return withEachDefinition({
        where: function(def, win) {
          var ref;
          return (win != null) && (def != null ? (ref = def.patterns) != null ? ref.indexOf(pattern) : void 0 : void 0) >= 0;
        },
        run: callback,
        otherwise: callback
      });
    };

    withTabsMatching = function(patterns, callback) {
      var matches;
      if (!patterns) {
        return callback([]);
      }
      if (typeof patterns === 'string' || typeof patterns === 'function') {
        patterns = [patterns];
      }
      if (patterns.length === 0 || patterns[0] === '') {
        return callback([]);
      }
      matches = (function(_this) {
        return function(tab) {
          var j, len, p, r;
          for (j = 0, len = patterns.length; j < len; j++) {
            p = patterns[j];
            if (typeof p === 'function') {
              if (p(tab)) {
                return true;
              }
            } else if (/^\/.+\/$/.test(p)) {
              r = new RegExp(p.substring(1, p.length - 1));
              if (r.test(tab.url) || r.test(tab.title)) {
                return true;
              }
            } else if (isRegex(p)) {
              r = new RegExp(p);
              if (r.test(tab.url) || r.test(tab.title)) {
                return true;
              }
            } else {
              if (tab.url.toLowerCase().search(p) > -1 || tab.title.toLowerCase().search(p) > -1) {
                return true;
              }
            }
          }
          return false;
        };
      })(this);
      return tabs.query({
        status: 'complete',
        windowType: 'normal'
      }, (function(_this) {
        return function(results) {
          var tab;
          return callback((function() {
            var j, len, results1;
            results1 = [];
            for (j = 0, len = results.length; j < len; j++) {
              tab = results[j];
              if (matches(tab)) {
                results1.push(tab.id);
              }
            }
            return results1;
          })());
        };
      })(this));
    };

    withEachWindow = function(args) {
      var action, condition, finish, otherwise, reduce;
      condition = args.where || function() {
        return true;
      };
      action = args.run;
      finish = args.then;
      reduce = args.reduce || function(msgs) {
        return msgs.join(',');
      };
      otherwise = args.otherwise;
      return windows.getAll({}, function(wins) {
        var def, j, len, msgs, win;
        msgs = [];
        for (j = 0, len = wins.length; j < len; j++) {
          win = wins[j];
          def = getDefinition(win);
          if (condition(win, def)) {
            msgs.push(action(win, def));
          }
        }
        if (finish != null) {
          return finish(reduce(msgs));
        } else if (msgs.length === 0 && (otherwise != null)) {
          return otherwise();
        }
      });
    };

    windowMatching = function(arg) {
      switch (typeof arg) {
        case 'string':
          return (function(_this) {
            return function(win) {
              return getName(win) === arg;
            };
          })(this);
        case 'number':
          return (function(_this) {
            return function(win) {
              return win.id === arg;
            };
          })(this);
        case 'function':
          return arg;
        case 'object':
          return (function(_this) {
            return function(win) {
              var k, v;
              return ((function() {
                var results1;
                results1 = [];
                for (k in arg) {
                  if (!hasProp.call(arg, k)) continue;
                  v = arg[k];
                  results1.push(win[k] === v);
                }
                return results1;
              })()).reduce(function(t, s) {
                return t && s;
              });
            };
          })(this);
        default:
          return alert("Can't use this argument type. " + (typeof arg) + " " + arg);
      }
    };

    withExistingWindow = function(arg, callback) {
      return withEachWindow({
        where: windowMatching(arg),
        run: callback
      });
    };

    withWindow = function(arg, callback) {
      return withEachWindow({
        where: windowMatching(arg),
        run: callback,
        otherwise: callback
      });
    };

    withEachDefinition = function(args) {
      var action, condition, finish, otherwise, reduce;
      condition = args.where || function() {
        return true;
      };
      action = args.run;
      finish = args.then;
      reduce = args.reduce || function(msgs) {
        return msgs.join(',');
      };
      otherwise = args.otherwise;
      return windows.getAll({}, function(wins) {
        var def, findWin, msgs, name, win;
        findWin = function(name) {
          var j, len, win;
          for (j = 0, len = wins.length; j < len; j++) {
            win = wins[j];
            if (getName(win) === name) {
              return win;
            }
          }
        };
        msgs = [];
        for (name in definitions) {
          if (!hasProp.call(definitions, name)) continue;
          def = definitions[name];
          win = findWin(name);
          if (condition(def, win)) {
            msgs.push(action(def, win));
          }
        }
        if (finish != null) {
          return finish(reduce(msgs));
        } else if (msgs.length === 0 && (otherwise != null)) {
          return otherwise();
        }
      });
    };

    withActiveTab = function(callback) {
      return tabs.query({
        active: true,
        currentWindow: true
      }, function(tabs) {
        return callback(tabs[0]);
      });
    };

    withNewWindow = function(name, callback) {
      return windows.create({
        type: 'normal'
      }, function(win) {
        if (name != null) {
          if (getDefinition(name) == null) {
            definitions[name] = {
              id: win.id,
              name: name
            };
          }
          setName(win, name);
        }
        return callback(win);
      });
    };

    TabShepherd.prototype.withCurrentWindow = function(callback) {
      return withCurrentWindow(callback);
    };

    withCurrentWindow = function(callback) {
      return windows.getCurrent({}, function(win) {
        return callback(win);
      });
    };

    withWindowNamed = function(name, callback) {
      return windows.getAll({}, function(wins) {
        var j, len, win;
        for (j = 0, len = wins.length; j < len; j++) {
          win = wins[j];
          if (getName(win) === name) {
            return callback(win);
          }
        }
        return callback(void 0);
      });
    };

    withHighlightedTab = function(win, callback) {
      return tabs.query({
        active: true,
        windowId: win.id
      }, function(tabs) {
        if (tabs.length > 0) {
          return callback(tabs[0]);
        }
      });
    };

    plur = function(word, num) {
      var text;
      text = num === 1 ? word : /y$/.test(word) ? word.slice(0) + 'ies' : /s$/.test(word) ? word + 'es' : word + 's';
      return num + " " + text;
    };

    Command = (function() {
      var close, cmd, output, saveData;

      saveData = null;

      output = null;

      cmd = null;

      function Command(text, _output) {
        var poss;
        poss = getPossibleCommands(text);
        if (poss.length === 1) {
          this.name = poss[0];
          cmd = commands[this.name];
        } else {
          this.name = text.replace(/\s.*/, '');
          cmd = commands['help'];
        }
        this.args = getArgs(text);
        output = _output;
      }

      close = function() {
        return storeDefinitions();
      };

      Command.prototype.exec = function(f) {
        return loadDefinitions((function(_this) {
          return function() {
            return f.apply(_this, _this.args);
          };
        })(this));
      };

      Command.prototype.finish = function() {
        var a, args, status;
        args = (function() {
          var j, len, results1;
          results1 = [];
          for (j = 0, len = arguments.length; j < len; j++) {
            a = arguments[j];
            results1.push(a);
          }
          return results1;
        }).apply(this, arguments);
        status = makeText.apply(null, args);
        if (status != null) {
          if (this.name === 'help') {
            output(status);
          } else {
            output(this.name + ": " + status);
          }
        }
        if (saveData) {
          return close();
        }
      };

      Command.prototype.run = function() {
        saveData = true;
        return this.exec(cmd.run);
      };

      Command.prototype.help = function() {
        saveData = false;
        return this.exec(cmd.help);
      };

      return Command;

    })();

    TabShepherd.prototype.getCommands = function() {
      return commands;
    };

    commands = {
      tabs: {
        desc: "Show active tab information",
        type: 'Informational',
        examples: {
          "ts tabs": "Show information on each active tab."
        },
        help: function() {
          return this.finish("Press enter to see active tab information.");
        },
        run: function() {
          return tabs.query({
            active: true
          }, (function(_this) {
            return function(t) {
              var tab;
              return _this.finish(((function() {
                var j, len, results1;
                results1 = [];
                for (j = 0, len = t.length; j < len; j++) {
                  tab = t[j];
                  results1.push(tab.windowId + ": " + tab.url);
                }
                return results1;
              })()).join("\n"));
            };
          })(this));
        }
      },
      wins: {
        desc: "Show window information",
        type: 'Informational',
        examples: {
          "ts tabs": "Show window information."
        },
        help: function() {
          return this.finish("Press enter to see window information.");
        },
        run: function() {
          return windows.getAll((function(_this) {
            return function(wins) {
              var win;
              return _this.finish(((function() {
                var j, len, results1;
                results1 = [];
                for (j = 0, len = wins.length; j < len; j++) {
                  win = wins[j];
                  results1.push(win.id + ": " + (getName(win)));
                }
                return results1;
              })()).join("\n"));
            };
          })(this));
        }
      },
      window: {
        desc: "Show the current window's ID",
        type: 'Informational',
        examples: {
          "ts id": "Show the current window's ID."
        },
        help: function() {
          return withCurrentWindow((function(_this) {
            return function(win) {
              return _this.finish("This window's ID is %s and its name is %w", win.id, getName(win));
            };
          })(this));
        },
        run: function() {
          return withCurrentWindow((function(_this) {
            return function(win) {
              return _this.finish("This window's ID is %s and its name is %w", win.id, getName(win));
            };
          })(this));
        }
      },
      name: {
        desc: 'Change the name of the current window definition',
        type: 'Managing window definitions',
        examples: {
          'ts name awesome': "Create a definition for the current window named 'awesome'."
        },
        help: function(newName) {
          return withCurrentWindow((function(_this) {
            return function(win) {
              if (getName(win) != null) {
                if (newName != null) {
                  return _this.finish("Press enter to change window name from %w to %w.", getName(win), newName);
                } else {
                  return _this.finish("Enter a new name for this window (currently named %w).", getName(win));
                }
              } else {
                if (newName != null) {
                  return _this.finish("Press enter to name this window %w.", newName);
                } else {
                  return _this.finish('Enter a name for this window.');
                }
              }
            };
          })(this));
        },
        run: function(name) {
          return withCurrentWindow((function(_this) {
            return function(win) {
              if (name == null) {
                return _this.finish('No name provided.');
              } else {
                setName(win, name);
                return _this.finish();
              }
            };
          })(this));
        }
      },
      defs: {
        desc: 'List named window definitions',
        type: 'Managing window definitions',
        examples: {
          'ts defs': 'List all the window definitions that exist.'
        },
        help: function() {
          return this.finish('Press enter to list the window definitions.');
        },
        run: function() {
          if ((definitions != null ? definitions.toread : void 0) != null) {
            console.log(Object.keys(definitions != null ? definitions.toread : void 0));
          }
          return withEachDefinition({
            run: (function(_this) {
              return function(def, win) {
                var winText;
                winText = win != null ? 'window ' + win.id : 'no attached window';
                return def.name + " (" + winText + ")\n" + def.firstUrl;
              };
            })(this),
            reduce: (function(_this) {
              return function(msgs) {
                return msgs.join("\n");
              };
            })(this),
            then: (function(_this) {
              return function(text) {
                return _this.finish('Named windows:\n\n%s', text);
              };
            })(this)
          });
        }
      },
      "new": {
        desc: 'Create a new window and assign it a definition',
        type: 'Managing window definitions',
        examples: {
          'ts new cats': "Create a new window with definition named 'cats'.",
          'ts new cats \\bcats?\\b': "Create a new window with definition named 'cats' and containing one pattern. Move no tabs."
        },
        help: function() {
          var name, patterns;
          name = arguments[0], patterns = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (!name) {
            return this.finish('Enter a name for the new window.');
          }
          return withWindowNamed(name, (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish("There is already a window named %w.", name);
              } else if (patterns.length === 0) {
                return _this.finish("Press enter to open a new window and name it %w.", name);
              } else if (patterns.length === 1) {
                return _this.finish("Press enter to open a new window named %w and assign it the pattern %p.", name, _this.args[1]);
              } else {
                return _this.finish("Press enter to open a new window named %w and assign it the given patterns.", name);
              }
            };
          })(this));
        },
        run: function() {
          var name, patterns;
          name = arguments[0], patterns = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (!name) {
            return this.finish('No window name provided.');
          }
          return withWindowNamed(name, (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish("There is already a window named %w.", name);
              }
              return withNewWindow(name, function(win) {
                var def, j, len, p;
                def = getDefinition(name);
                for (j = 0, len = patterns.length; j < len; j++) {
                  p = patterns[j];
                  if (def.patterns == null) {
                    def.patterns = [];
                  }
                  def.patterns.push(p);
                }
                return _this.finish();
              });
            };
          })(this));
        }
      },
      clear: {
        desc: 'Clear window definitions',
        type: 'Managing window definitions',
        examples: {
          'ts clear recipes': "Remove the window definition 'recipes'. No tabs are affected.",
          'ts clear *': "Remove all window definitions from storage. No tabs are affected."
        },
        help: function(name) {
          if (name == null) {
            return this.finish('Enter a window definition name to remove.');
          }
          if (name === '*') {
            return this.finish('Press enter to clear all saved window definitions.');
          }
          return withWindowNamed(name, (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish("Press enter to clear window definition %w. Warning: currently assigned to a window.", name);
              } else if (getDefinition(name) != null) {
                return _this.finish("Press enter to clear window definition %w, not currently assigned to a window.", name);
              } else {
                return _this.finish("Window definition %w not found.", name);
              }
            };
          })(this));
        },
        run: function(name) {
          var def;
          if (name == null) {
            return this.finish('Enter a window definition name');
          }
          if (name === '*') {
            for (name in definitions) {
              if (!hasProp.call(definitions, name)) continue;
              def = definitions[name];
              deleteDefinition(name);
            }
            return this.finish('Cleared all window definitions.');
          } else {
            return withWindowNamed(name, (function(_this) {
              return function(win) {
                if (win != null) {
                  deleteDefinition(name);
                  return _this.finish("Cleared window definition %w and removed it from a window.", name);
                } else if (getDefinition(name) != null) {
                  deleteDefinition(name);
                  return _this.finish("Cleared window definition %w.", name);
                } else {
                  return _this.finish("Window definition %w not found.", name);
                }
              };
            })(this));
          }
        }
      },
      clean: {
        desc: 'Clean window data, removing definitions for which no window is present',
        type: 'Managing window definitions',
        examples: {
          'ts clean': 'Clean window data, removing definitions for which no window is present. No tabs are affected.'
        },
        help: function() {
          return withEachDefinition({
            where: function(def, win) {
              return !win;
            },
            run: function(def) {
              return "'" + def.name + "'";
            },
            then: (function(_this) {
              return function(msg) {
                return _this.finish(msg ? 'Press enter to clean unused window definitions: ' + msg : 'No window definitions need cleaning.');
              };
            })(this)
          });
        },
        run: function() {
          return withEachDefinition({
            where: function(def, win) {
              return !win;
            },
            run: (function(_this) {
              return function(def) {
                deleteDefinition(def.name);
                return "'" + def.name + "'";
              };
            })(this),
            then: (function(_this) {
              return function(msg) {
                return _this.finish(msg ? 'Cleaned unused window definitions: ' + msg : 'No window definitions needed cleaning.');
              };
            })(this)
          });
        }
      },
      unnamed: {
        desc: 'Go to a window having no definition',
        type: 'Managing window definitions',
        examples: {
          'ts unnamed': 'Find a window with no definition if such exists, and focus it; else do nothing.'
        },
        help: function() {
          return withWindow((function(win) {
            return getName(win) == null;
          }), (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish('Press enter to go to an open window that has no definition.');
              } else {
                return _this.finish('All windows have a definition.');
              }
            };
          })(this));
        },
        run: function() {
          return withWindow((function(win) {
            return getName(win) == null;
          }), (function(_this) {
            return function(win) {
              if (win) {
                focus(win);
              }
              return _this.finish();
            };
          })(this));
        }
      },
      open: {
        desc: 'Open to the window with the given name, creating a new window if necessary',
        type: 'Changing focus',
        examples: {
          'ts focus work': "Focus the window with the definition \"work\" if it exists, otherwise create a window, give it definition \"work\" and focus it."
        },
        help: function(name) {
          if (name == null) {
            return this.finish("Enter a window name.");
          } else {
            return withWindow(name, (function(_this) {
              return function(win) {
                if (win != null) {
                  return _this.finish("Press enter to open window %w.", name);
                } else if (getDefinition(name) != null) {
                  return _this.finish("Press enter to open a new window for existing definition %w.", name);
                } else {
                  return _this.finish("Press enter to open new window %w.", name);
                }
              };
            })(this));
          }
        },
        run: function(name) {
          if (name == null) {
            return this.finish("Enter a window name.");
          } else {
            return withWindow(name, (function(_this) {
              return function(win) {
                if (win != null) {
                  focus(win);
                  return _this.finish();
                } else {
                  return withNewWindow(name, function(newWin) {
                    focus(newWin);
                    return _this.finish();
                  });
                }
              };
            })(this));
          }
        }
      },
      go: {
        desc: 'Perform either "find", "extract" or "open", depending on the arguments and number of matches',
        type: 'Changing focus',
        examples: {
          'ts go document': 'If there is one tab matching /document/, behave as "ts find document", else behave as "ts extract document".',
          'ts go "work"': 'If there is a window named "work", behave as "ts open work", otherwise behave as "ts new work".'
        },
        help: function(pattern, name) {
          if (name == null) {
            name = pattern;
          }
          if (/^"/.test(pattern)) {
            if (!getDefinition(name)) {
              return this.finish("Press enter to create a new window named %w", name.replace(/"/g, ""));
            } else {
              return this.finish("Press enter to focus window %w.", name.replace(/"/g, ""));
            }
          } else {
            return withTabsMatching(pattern, (function(_this) {
              return function(matchingTabsIds) {
                if (matchingTabsIds.length === 1) {
                  return _this.finish("Press enter to focus the single tab matching %p.", pattern);
                } else if (matchingTabsIds.length > 1) {
                  return _this.finish("Press enter to extract the %s tabs matching %p into a new window named %w.", matchingTabsIds.length, pattern, name);
                } else {
                  return _this.finish("No tabs found matching %p.", pattern);
                }
              };
            })(this));
          }
        },
        run: function(pattern, name) {
          var win;
          if (name == null) {
            name = pattern;
          }
          if (/^"/.test(pattern)) {
            win = pattern.replace(/"/g, "");
            if (!getDefinition(name)) {
              return withNewWindow(name, (function(_this) {
                return function() {
                  return _this.finish();
                };
              })(this));
            } else {
              return withWindow(name, (function(_this) {
                return function(win) {
                  if (win == null) {
                    _this.finish("Window not found: %w.", name);
                  }
                  focus(win);
                  return _this.finish();
                };
              })(this));
            }
          } else {
            return withTabsMatching(pattern, (function(_this) {
              return function(matchingTabsIds) {
                if (matchingTabsIds.length === 1) {
                  return tabs.get(matchingTabsIds[0], function(tab) {
                    return windows.update(tab.windowId, {
                      focused: true
                    }, function() {
                      return tabs.update(tab.id, {
                        active: true
                      }, function() {});
                    });
                  });
                } else if (matchingTabsIds.length > 1) {
                  return withNewWindow(name, function(win) {
                    return tabs.move(matchingTabsIds, {
                      windowId: win.id,
                      index: -1
                    }, (function(_this) {
                      return function() {
                        setName(win, name);
                        assignPattern(win, pattern);
                        return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                          return _this.finish();
                        });
                      };
                    })(this));
                  });
                } else {
                  return _this.finish("No tabs found matching %p.", pattern);
                }
              };
            })(this));
          }
        }
      },
      find: {
        desc: 'Go to the first tab found matching a pattern, never moving tabs',
        type: 'Changing focus',
        examples: {
          "ts find google.com": "Focus the first tab found to match 'google.com', or do nothing if no tab is found."
        },
        help: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to find a tab.');
          }
          return withTabsMatching(pattern, (function(_this) {
            return function(matchingTabs) {
              if (matchingTabs.length > 1) {
                return _this.finish("Press enter to focus the first of %s tabs matching %p.", matchingTabs.length, pattern);
              } else if (matchingTabs.length === 1) {
                return tabs.get(matchingTabs[0], function(tab) {
                  return windows.get(tab.windowId, {}, function(win) {
                    var name;
                    name = getName(win);
                    if (name != null) {
                      return _this.finish('Press enter to focus the tab matching %p in window %w.', pattern, name);
                    } else {
                      return _this.finish('Press enter to focus the tab matching %p.', pattern);
                    }
                  });
                });
              } else {
                return _this.finish('No matching tabs found for %p.', pattern);
              }
            };
          })(this));
        },
        run: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to find a tab.');
          }
          return withTabsMatching(pattern, (function(_this) {
            return function(matchingTabs) {
              if (matchingTabs.length >= 1) {
                return tabs.get(matchingTabs[0], function(tab) {
                  return windows.update(tab.windowId, {
                    focused: true
                  }, function() {
                    return tabs.update(tab.id, {
                      active: true
                    }, function() {});
                  });
                });
              } else {
                return _this.finish("No matching tabs found for %p.", pattern);
              }
            };
          })(this));
        }
      },
      bring: {
        desc: 'Bring tabs matching a pattern to the current window',
        type: 'Moving tabs',
        examples: {
          'ts bring cute.*bunnies.com': 'Bring tabs whose URLs match the given pattern (e.g. cutewhitebunnies.com and cutefluffybunnies.com) to the current window.',
          'ts bring': 'Bring tabs whose URLs match all this window\'s assigned patterns to this window.'
        },
        help: function() {
          var patterns;
          patterns = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return withCurrentWindow((function(_this) {
            return function(win) {
              var def, ref, usingAssigned;
              usingAssigned = patterns.length === 0;
              if (usingAssigned) {
                def = getDefinition(win);
                if (!(def != null ? (ref = def.patterns) != null ? ref.length : void 0 : void 0)) {
                  return _this.finish('Enter one or more patterns. No assigned patterns exist for this window.');
                }
                patterns = def.patterns;
              }
              return withTabsMatching(patterns, function(matchingTabs) {
                var extra, num;
                num = matchingTabs.length;
                if (num < 1) {
                  return _this.finish('No tabs found matching %s.', plur('given pattern', patterns.length));
                } else {
                  if (usingAssigned) {
                    extra = ", or enter different patterns";
                  }
                  return _this.finish('Press enter to bring %s matching %s to this window %w%s.', plur('tab', num), plur('pattern', patterns.length), getName(win), extra);
                }
              });
            };
          })(this));
        },
        run: function() {
          var patterns;
          patterns = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return withCurrentWindow((function(_this) {
            return function(win) {
              var def, usingAssigned;
              usingAssigned = patterns.length === 0;
              if (usingAssigned) {
                def = getDefinition(win);
                if (!def || !def.patterns || def.patterns.length === 0) {
                  return _this.finish('No patterns entered and this window has no assigned patterns.');
                }
                patterns = def.patterns;
              }
              return withTabsMatching(patterns, function(matchingTabs) {
                var pat, type;
                if (matchingTabs.length < 1) {
                  type = usingAssigned ? 'assigned pattern' : 'given pattern';
                  return _this.finish('No tabs found matching %s:\n\n%s', plur(type, patterns.length), ((function() {
                    var j, len, results1;
                    results1 = [];
                    for (j = 0, len = patterns.length; j < len; j++) {
                      pat = patterns[j];
                      results1.push(makeText("%p", pat));
                    }
                    return results1;
                  })()).join("\n"));
                } else {
                  return tabs.move(matchingTabs, {
                    windowId: win.id,
                    index: -1
                  }, function() {
                    return _this.finish();
                  });
                }
              });
            };
          })(this));
        }
      },
      send: {
        desc: 'Send the current tab to the window named in the argument, creating the window if necessary',
        type: 'Moving tabs',
        examples: {
          'ts send research': "Send the current tab to the window named 'research', first creating it if necessary."
        },
        help: function(name) {
          var win;
          if (name == null) {
            return this.finish('Enter a window name to send this tab there.');
          } else {
            win = getDefinition(name);
            return this.finish("Press enter to send this tab to %swindow %w.", (win != null ? '' : 'new '), name);
          }
        },
        run: function(name) {
          return withActiveTab((function(_this) {
            return function(tab) {
              var existingWin;
              existingWin = getDefinition(name);
              if (existingWin != null) {
                return tabs.move(tab.id, {
                  windowId: existingWin.id,
                  index: -1
                }, function() {
                  return _this.finish();
                });
              } else {
                return withNewWindow(name, function(win) {
                  return tabs.move(tab.id, {
                    windowId: win.id,
                    index: -1
                  }, function() {
                    return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                      return _this.finish();
                    });
                  });
                });
              }
            };
          })(this));
        }
      },
      extract: {
        desc: 'Extract tabs matching the pattern arguments into a new window named with that pattern',
        type: 'Moving tabs',
        examples: {
          'ts extract google': "Create a new window \"google\", assign pattern 'google' to that definition, and move all tabs whose URLs match the pattern there.",
          'ts extract social facebook.com twitter.com': "Create a new window, give it a definition named 'social', assign patterns 'facebook.com' and 'twitter.com' to that definition, and move all tabs whose URLs match the patterns there. This is effectively \"ts new social\", followed by \"ts assign facebook.com twitter.com\", then \"ts bring\". "
        },
        help: function() {
          var name, patterns;
          if (this.args.length === 0) {
            return this.finish('Enter a name or pattern.');
          } else {
            name = this.args[0];
            patterns = this.args.length === 1 ? [this.args[0]] : this.args.slice(1);
            return withTabsMatching(patterns, (function(_this) {
              return function(matchingTabs) {
                var num;
                num = matchingTabs.length;
                if (num < 1) {
                  return _this.finish('No tabs found matching %p. Enter more args to use it as a name.', name);
                } else if (patterns.length > 1) {
                  return _this.finish("Press enter to extract %s matching %s patterns into a new window named %w.", plur("tab", num), patterns.length, name);
                } else {
                  return _this.finish("Press enter to extract %s matching %p into a new window named %w.", plur("tab", num), patterns[0], name);
                }
              };
            })(this));
          }
        },
        run: function() {
          var name, patterns;
          if (this.args.length === 0) {
            return this.finish('Enter a name or pattern.');
          } else {
            name = this.args[0];
            patterns = this.args.length === 1 ? [this.args[0]] : this.args.slice(1);
            return withTabsMatching(patterns, (function(_this) {
              return function(matchingTabs) {
                if (matchingTabs.length < 1) {
                  return _this.finish('No tabs found matching the given pattern(s).');
                } else {
                  return withNewWindow(name, function(win) {
                    return tabs.move(matchingTabs, {
                      windowId: win.id,
                      index: -1
                    }, function() {
                      var j, len, p;
                      setName(win, name);
                      for (j = 0, len = patterns.length; j < len; j++) {
                        p = patterns[j];
                        assignPattern(win, p);
                      }
                      return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                        return _this.finish();
                      });
                    });
                  });
                }
              };
            })(this));
          }
        }
      },
      sort: {
        desc: 'Sort all tabs into windows by assigned patterns',
        type: 'Moving tabs',
        examples: {
          'ts sort': "Move all tabs that match a defined pattern to that pattern's window. Effectively, perform \"ts bring\" for each window."
        },
        help: function() {
          return this.finish('Press enter to sort all windows according to their assigned patterns.');
        },
        run: function() {
          var def, name, results1;
          results1 = [];
          for (name in definitions) {
            if (!hasProp.call(definitions, name)) continue;
            def = definitions[name];
            if (def.patterns != null) {
              results1.push(withWindowNamed(name, (function(_this) {
                return function(win) {
                  return withTabsMatching(def.patterns, function(tabz) {
                    return tabs.move(tabz, {
                      windowId: win.id,
                      index: -1
                    }, function() {
                      return _this.finish();
                    });
                  });
                };
              })(this)));
            }
          }
          return results1;
        }
      },
      merge: {
        desc: 'Merge all tabs and patterns from another window into this window.',
        type: 'Moving tabs',
        examples: {
          'ts merge restaurants': "Move all the tabs and patterns from window 'restaurants' into the current window and remove the 'restaurants' definition."
        },
        help: function(name) {
          if (name == null) {
            return this.finish('Enter a defined window name.');
          }
          return withWindow(name, (function(_this) {
            return function(win) {
              if (win == null) {
                return _this.finish('No such window %w', name);
              }
              return withTabsMatching((function(tab) {
                return tab.windowId === win.id;
              }), function(tabz) {
                var patterns, ref, ref1;
                patterns = (ref = (ref1 = getDefinition(win)) != null ? ref1.patterns : void 0) != null ? ref : [];
                return withCurrentWindow(function(currWin) {
                  return _this.finish('Press enter to move %s and %s from window %w to this window %w.', plur('tab', tabz.length), plur('pattern', patterns.length), name, getName(currWin));
                });
              });
            };
          })(this));
        },
        run: function(name) {
          if (name == null) {
            return this.finish('Enter a defined window name.');
          }
          return withWindow(name, (function(_this) {
            return function(win) {
              if (win == null) {
                return _this.finish('No such window %w', name);
              }
              return withTabsMatching((function(tab) {
                return tab.windowId === win.id;
              }), function(tabz) {
                var def;
                def = getDefinition(win);
                if (def == null) {
                  return _this.finish("Window %w has no definition!");
                }
                return withCurrentWindow(function(currWin) {
                  var currDef, j, len, p, ref, ref1;
                  currDef = getDefinition(currWin);
                  if (currDef.patterns == null) {
                    currDef.patterns = [];
                  }
                  ref1 = (ref = def.patterns) != null ? ref : [];
                  for (j = 0, len = ref1.length; j < len; j++) {
                    p = ref1[j];
                    currDef.patterns.push(p);
                  }
                  return tabs.move(tabz, {
                    windowId: currWin.id,
                    index: -1
                  }, function() {
                    return delete definitions[name];
                  });
                });
              });
            };
          })(this));
        }
      },
      split: {
        desc: 'Split a window in two, moving half of the tabs to a new window.',
        type: 'Moving tabs',
        examples: {
          'ts split': 'Move the last half the tabs in the current window into a new window.'
        },
        help: function() {
          return this.finish("Press enter to split this window in two.");
        },
        run: function() {
          return withCurrentWindow((function(_this) {
            return function(win) {
              return withTabsMatching((function(tab) {
                return tab.windowId === win.id;
              }), function(matchingTabs) {
                if (matchingTabs.length >= 2) {
                  return withNewWindow(void 0, function(newWin) {
                    return tabs.move(matchingTabs.slice(matchingTabs.length / 2), {
                      windowId: newWin.id,
                      index: -1
                    }, function() {
                      return _this.finish();
                    });
                  });
                }
              });
            };
          })(this));
        }
      },
      assign: {
        desc: 'Assign a pattern to the current window',
        type: 'Managing URL patterns',
        examples: {
          'ts assign reddit.com': "Add /reddit.com/ to this window's assigned patterns. No tabs are affected."
        },
        help: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to assign to this window.');
          } else {
            return withWindowForPattern(pattern, (function(_this) {
              return function(currWin) {
                if (currWin != null) {
                  return _this.finish("Press enter to reassign %p to this window from window %w.", pattern, getName(currWin));
                } else {
                  return _this.finish('Press enter to assign %p to this window.', pattern);
                }
              };
            })(this));
          }
        },
        run: function(pattern) {
          if (pattern == null) {
            return this.finish('No pattern provided.');
          } else {
            return withCurrentWindow((function(_this) {
              return function(window) {
                return withWindowForPattern(pattern, function(currWin) {
                  var msg;
                  msg = void 0;
                  if (currWin != null) {
                    if (unassignPattern(currWin, pattern)) {
                      msg = makeText('Pattern %p was moved from window %w to window %w.', pattern, getName(currWin), getName(window));
                    } else {
                      _this.finish('Could not unassign pattern %p from window %w.', pattern, getName(currWin));
                    }
                  }
                  if (assignPattern(window, pattern)) {
                    return _this.finish(msg);
                  } else {
                    return _this.finish('Could not assign pattern %p to window %w.', pattern, getName(window));
                  }
                });
              };
            })(this));
          }
        }
      },
      unassign: {
        desc: 'Remove a pattern assignment from the current window',
        type: 'Managing URL patterns',
        examples: {
          'ts unassign reddit.com': 'Remove /reddit.com/ from this window\'s patterns if it is assigned. No tabs are affected.'
        },
        help: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to remove from this window.');
          } else if (!containsPattern(pattern, window)) {
            return this.finish('Pattern %p is not assigned to this window.', pattern);
          } else {
            return this.finish('Press enter to remove %p from this window.', pattern);
          }
        },
        run: function(pattern) {
          if (pattern == null) {
            return this.finish('No pattern provided.');
          } else if (!containsPattern(pattern, window)) {
            return this.finish('Pattern %p is not assigned to this window.');
          } else {
            return withCurrentWindow((function(_this) {
              return function(window) {
                if (unassignPattern(window, pattern)) {
                  return _this.finish();
                } else {
                  return _this.finish('Could not unassign pattern %s from window %w.', pattern, getName(window));
                }
              };
            })(this));
          }
        }
      },
      patterns: {
        desc: 'List patterns assigned to the current window definition',
        type: 'Managing URL patterns',
        examples: {
          'ts patterns': 'List patterns assigned to the current window.'
        },
        help: function() {
          return this.finish('Press enter to list the patterns assigned to this window.');
        },
        run: function() {
          return withCurrentWindow((function(_this) {
            return function(window) {
              return _this.finish("Patterns assigned to window %w:\n\n" + listPatterns(window), getName(window));
            };
          })(this));
        }
      },
      help: {
        desc: 'Get help on a command',
        type: 'Informational',
        examples: {
          'ts help bring': 'Show usage examples for the "bring" command.'
        },
        help: function() {
          var cmd, cmds;
          if (this.name === 'help') {
            if (this.args.length > 0) {
              cmd = getCommand(this.args[0]);
              if ((cmd == null) || cmd === commands['help']) {
                return this.finish(this.args[0] + ": No matching command found.");
              } else {
                return this.finish(this.args[0] + ": " + cmd.desc);
              }
            } else {
              return this.finish('help: Enter a command name or press enter to see possible commands.');
            }
          } else {
            cmds = getPossibleCommands(this.name);
            if (cmds.length === 0) {
              return this.finish(this.name + ": No matching command found.");
            } else {
              return this.finish("[" + (cmds.join('/')) + "] Keep typing to narrow command results.");
            }
          }
        },
        run: function() {
          if (this.args.length > 0) {
            return this.finish("/help.html?command=" + this.args[0]);
          } else {
            return this.finish("/help.html");
          }
        }
      }
    };

    return TabShepherd;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.TabShepherd = TabShepherd;

}).call(this);
