// Generated by CoffeeScript 1.9.1
(function() {
  var TabShepherd, root,
    hasProp = {}.hasOwnProperty;

  TabShepherd = (function() {
    var Command, alert, assignPattern, commands, containsPattern, definitions, deleteDefinition, focus, getArgs, getCommand, getDefForPattern, getDefinition, getId, getName, listPatterns, loadDefinitions, makeText, omnibox, runtime, setName, showExamples, storage, storeDefinitions, summarizeCommands, tabs, unassignPattern, windows, withActiveTab, withCurrentWindow, withEachDefinition, withEachWindow, withFirstTab, withNewWindow, withTabsMatching, withWindow, withWindowForPattern, withWindowNamed;

    storage = null;

    omnibox = null;

    windows = null;

    tabs = null;

    runtime = null;

    definitions = null;

    alert = null;

    function TabShepherd(chrome, _alert) {
      storage = chrome.storage.local;
      omnibox = chrome.omnibox;
      windows = chrome.windows;
      tabs = chrome.tabs;
      runtime = chrome.runtime;
      alert = _alert;
      storage.get('windowDefs', (function(_this) {
        return function(data) {
          var defMatchesWin;
          definitions = data['windowDefs'] || {};
          defMatchesWin = function(def, win, tabs) {
            return def.id === win.id || (tabs[0] && def.firstUrl === tabs[0].url);
          };
          return withEachWindow({
            run: function(win) {
              return tabs.getAllInWindow(win.id, function(tabs) {
                var def, defName, results;
                results = [];
                for (defName in definitions) {
                  if (!hasProp.call(definitions, defName)) continue;
                  def = definitions[defName];
                  if (!(defMatchesWin(def, win, tabs))) {
                    continue;
                  }
                  win.name = defName;
                  results.push(win.def = def);
                }
                return results;
              });
            }
          });
        };
      })(this));
      omnibox.onInputChanged.addListener((function(_this) {
        return function(text, suggest) {
          var c;
          c = new Command(text, function(res) {
            if (res) {
              return suggest([
                {
                  content: ' ',
                  description: res
                }
              ]);
            }
          });
          return c.help();
        };
      })(this));
      omnibox.onInputEntered.addListener((function(_this) {
        return function(text) {
          var c;
          c = new Command(text, function(res) {
            if (res) {
              return alert(res);
            }
          });
          return c.run();
        };
      })(this));
      windows.onRemoved.addListener((function(_this) {
        return function(windowId) {
          return withWindow(windowId, function(win) {
            var def;
            if ((win.name != null)) {
              def = getDefinition(win.name);
              return withFirstTab(win, function(tab) {
                def.firstUrl = tab.url;
                return storeDefinitions();
              });
            }
          });
        };
      })(this));
    }

    TabShepherd.prototype.commands = function() {
      return commands;
    };

    getCommand = function(text) {
      var idx, name;
      idx = text ? text.indexOf(' ') : -1;
      name = idx === -1 ? text : text.substring(0, idx);
      if (commands[name]) {
        if (commands[name]['alias']) {
          return commands[commands[name]['alias']];
        } else {
          return commands[name];
        }
      } else {
        return commands['help'];
      }
    };

    getArgs = function(text) {
      text = text.trim();
      if (!/^\w+\s+\w+/.test(text)) {
        return [];
      }
      return text.replace(/^\w+\s+/, '').split(/\s+/);
    };

    makeText = function(args) {
      var a, arr, j, len, msg, ref;
      arr = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = args.length; j < len; j++) {
          a = args[j];
          results.push(a);
        }
        return results;
      })();
      if (arr.length === 0) {
        return void 0;
      }
      msg = arr[0];
      if (arr.length === 1) {
        return msg;
      }
      ref = arr.slice(1);
      for (j = 0, len = ref.length; j < len; j++) {
        a = ref[j];
        msg = msg.replace('%s', a);
      }
      return msg;
    };

    getId = function(win) {
      if (typeof win === 'number') {
        return win;
      } else if (typeof win === 'object') {
        return win.id;
      } else {
        return alert("Can't find id from " + typeof win);
      }
    };

    showExamples = function(cmd) {
      var command, ex, examples, msg;
      if (commands[cmd] == null) {
        return '';
      }
      msg = '"' + cmd + '": ' + commands[cmd].desc + '.\n\nExamples:\n\n';
      command = commands[cmd];
      examples = command.examples;
      for (ex in examples) {
        msg += ex + "\n  " + examples[ex] + "\n\n";
      }
      return msg;
    };

    summarizeCommands = function(full) {
      var cmd, j, len, msg, name, type, types;
      if (full && full !== true) {
        return showExamples(full);
      }
      msg = '';
      if (full) {
        msg += 'Syntax: ts <command> <arguments>\n\n';
      }
      msg += 'Possible commands:' + (full ? '\n' : ' ');
      types = ['Moving tabs', 'Changing focus', 'Managing window definitions', 'Managing URL patterns', 'Help'];
      for (j = 0, len = types.length; j < len; j++) {
        type = types[j];
        if (full) {
          msg += "  " + type + ":\n";
        }
        for (name in commands) {
          if (!hasProp.call(commands, name)) continue;
          cmd = commands[name];
          if (cmd.type === type) {
            if (full) {
              msg += "    " + name + ": " + cmd.desc + ".\n";
            } else {
              msg += name + ' ';
            }
          }
        }
      }
      return msg;
    };

    focus = function(win) {
      return windows.update(win.id, {
        focused: true
      }, function() {});
    };

    deleteDefinition = function(name) {
      return delete definitions[name];
    };

    TabShepherd.prototype.getDefinition = function(name) {
      return getDefinition(name);
    };

    getDefinition = function(name) {
      return definitions[name];
    };

    TabShepherd.prototype.storeDefinitions = function() {
      return storeDefinitions();
    };

    storeDefinitions = function() {
      return storage.set({
        windowDefs: definitions
      }, function() {
        if (runtime.lastError) {
          return alert(runtime.lastError);
        }
      });
    };

    loadDefinitions = function(callback) {
      return storage.get('windowDefs', function(data) {
        definitions = data['windowDefs'] || {};
        return callback();
      });
    };

    TabShepherd.prototype.setName = function(win, name) {
      return setName(win, name);
    };

    setName = function(win, name) {
      if (definitions[win.name] != null) {
        definitions[name] = definitions[win.name];
        delete definitions[win.name];
      } else {
        definitions[name] = {
          id: win.id
        };
      }
      win.name = name;
      win.def = definitions[name];
      return win.def.name = name;
    };

    getName = function(win) {
      var id, name;
      id = getId(win);
      for (name in definitions) {
        if (!hasProp.call(definitions, name)) continue;
        if (definitions[name].id === id) {
          return name;
        }
      }
    };

    getDefForPattern = function(pattern) {
      var def, j, len, name, ref;
      for (name in definitions) {
        if (!hasProp.call(definitions, name)) continue;
        def = definitions[name];
        if (def.patterns) {
          ref = def.patterns;
          for (j = 0, len = ref.length; j < len; j++) {
            pattern = ref[j];
            if (pattern === def.patterns[i]) {
              return def;
            }
          }
        }
      }
    };

    TabShepherd.prototype.assignPattern = function(pattern, win) {
      return assignPattern(pattern, win);
    };

    assignPattern = function(pattern, win) {
      var def, name;
      name = win.name;
      if (name == null) {
        alert('Window has no name!');
        return false;
      }
      if (definitions[name] == null) {
        alert("Window " + name + " has no definition!");
        return false;
      }
      def = definitions[name];
      if (def.patterns == null) {
        def.patterns = [];
      }
      def.patterns.push(pattern);
      return true;
    };

    unassignPattern = function(pattern, window) {
      var def, i;
      if (window.name == null) {
        alert('Window has no name.');
        return false;
      }
      def = definitions[window.name];
      if (def == null) {
        alert('No definition found for name ' + window.name);
        return false;
      }
      if (def.patterns == null) {
        alert('No patterns found in window ' + window.name);
        return false;
      }
      i = 0;
      while (i < def.patterns.length) {
        if (def.patterns[i] === pattern) {
          def.patterns.splice(i, 1);
          return true;
        }
        i++;
      }
      alert("Could not delete pattern " + pattern + " from window '" + window.name + "'.");
      return false;
    };

    containsPattern = function(pattern) {
      var j, len, regex, regexes;
      if (!definitions[window.name]) {
        alert('Unknown window ' + window.name);
      }
      regexes = definitions[window.name].regexes;
      if (!regexes) {
        return false;
      }
      for (j = 0, len = regexes.length; j < len; j++) {
        regex = regexes[j];
        if (regex === pattern) {
          return true;
        }
      }
      return false;
    };

    listPatterns = function(window) {
      var def, j, len, patt, patterns, results;
      def = definitions[window.name];
      if (!def) {
        return '';
      }
      patterns = def.patterns || [];
      results = [];
      for (j = 0, len = patterns.length; j < len; j++) {
        patt = patterns[j];
        results.push("/" + patt + "/\n");
      }
      return results;
    };

    withWindowForPattern = function(pattern, callback) {
      var def;
      def = getDefForPattern(pattern);
      if (def == null) {
        return callback();
      }
      if (def.id == null) {
        return alert("Definition " + def + " found for pattern " + pattern + " but it has no assigned window.");
      } else {
        return windows.get(def.id, {}, (function(_this) {
          return function(w) {
            w.def = def;
            return callback(w);
          };
        })(this));
      }
    };

    withTabsMatching = function(patterns, callback) {
      var matches;
      if (!patterns) {
        return callback([]);
      }
      if (typeof patterns === 'string') {
        patterns = [patterns];
      }
      if (patterns.length === 0 || patterns[0] === '') {
        return callback([]);
      }
      matches = (function(_this) {
        return function(tab) {
          var j, len, p, r;
          for (j = 0, len = patterns.length; j < len; j++) {
            p = patterns[j];
            if (/^\/.*\/$/.test(p)) {
              r = new RegExp(p);
              if (r.test(tab.url) || r.test(tab.title)) {
                return true;
              }
            } else if (/[*+?{}\[\]]/.test(p)) {
              r = new RegExp('/' + p.replace(/\//, '\\/') + '/i');
              if (r.test(tab.url) || r.test(tab.title)) {
                return true;
              }
            } else {
              if (tab.url.toLowerCase().search(p) > -1 || tab.title.toLowerCase().search(p) > -1) {
                return true;
              }
            }
          }
          return false;
        };
      })(this);
      return tabs.query({
        pinned: false,
        status: 'complete',
        windowType: 'normal'
      }, (function(_this) {
        return function(tabs) {
          var matchingTabs, tab;
          matchingTabs = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = tabs.length; j < len; j++) {
              tab = tabs[j];
              if (matches(tab)) {
                results.push(tab.id);
              }
            }
            return results;
          })();
          return callback(matchingTabs);
        };
      })(this));
    };

    withEachWindow = function(args) {
      var action, condition, finish, reduce;
      condition = args.where || (function(_this) {
        return function() {
          return true;
        };
      })(this);
      action = args.run;
      finish = args.then;
      reduce = args.reduce || (function(_this) {
        return function(msgs) {
          return msgs.join(',');
        };
      })(this);
      return windows.getAll({}, (function(_this) {
        return function(wins) {
          var def, j, len, msgs, results, win;
          results = [];
          for (j = 0, len = wins.length; j < len; j++) {
            win = wins[j];
            def = definitions[win.name];
            msgs = (function() {
              var l, len1, results1;
              results1 = [];
              for (l = 0, len1 = wins.length; l < len1; l++) {
                win = wins[l];
                if (condition(win, def, win.name)) {
                  results1.push(action(win, def, win.name));
                }
              }
              return results1;
            })();
            if (finish != null) {
              results.push(finish(reduce(msgs)));
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
      })(this));
    };

    withWindow = function(arg, callback) {
      var where;
      where = typeof arg === 'string' ? (function(_this) {
        return function(win) {
          return win.name === arg;
        };
      })(this) : typeof arg === 'number' ? (function(_this) {
        return function(win) {
          return win.id === arg;
        };
      })(this) : typeof arg === 'function' ? arg : typeof arg === 'object' ? (function(_this) {
        return function(win) {
          var all, k, v;
          all = (function() {
            var results;
            results = [];
            for (k in arg) {
              if (!hasProp.call(arg, k)) continue;
              v = arg[k];
              results.push(win[k] === v);
            }
            return results;
          })();
          return all.reduce(function(t, s) {
            return t && s;
          });
        };
      })(this) : (alert("Can't use this argument type."), void 0);
      if (where) {
        return withEachWindow({
          where: where,
          run: callback
        });
      }
    };

    withEachDefinition = function(args) {
      var action, condition, finish, reduce;
      condition = args.where || function() {
        return true;
      };
      action = args.run;
      finish = args.then;
      reduce = args.reduce || function(msgs) {
        return msgs.join(',');
      };
      return windows.getAll({}, function(wins) {
        var def, findWin, msgs, name, win;
        findWin = function(defName) {
          var j, len, win;
          for (j = 0, len = wins.length; j < len; j++) {
            win = wins[j];
            if (win.name === defName) {
              return win;
            }
          }
        };
        msgs = (function() {
          var results;
          results = [];
          for (name in definitions) {
            if (!hasProp.call(definitions, name)) continue;
            def = definitions[name];
            if ((win = findWin(name)) && condition(def, win, name)) {
              results.push(action(def, win, name));
            }
          }
          return results;
        })();
        if (finish != null) {
          return finish(reduce(msgs));
        }
      });
    };

    withActiveTab = function(callback) {
      return tabs.query({
        active: true,
        currentWindow: true
      }, function(tabs) {
        return callback(tabs[0]);
      });
    };

    withNewWindow = function(name, callback) {
      return windows.create({
        type: 'normal'
      }, function(win) {
        definitions[name] = {
          id: win.id,
          name: name
        };
        win.name = name;
        return callback(win);
      });
    };

    TabShepherd.prototype.withCurrentWindow = function(callback) {
      return withCurrentWindow(callback);
    };

    withCurrentWindow = function(callback) {
      return windows.getCurrent({}, function(win) {
        win.name = getName(win);
        return callback(win);
      });
    };

    withWindowNamed = function(name, callback) {
      return withWindow((function(win) {
        return win.name === name;
      }), callback);
    };

    withFirstTab = function(win, callback) {
      return tabs.query({
        index: 0,
        windowId: win.id
      }, function(tab) {
        return callback(tab);
      });
    };

    Command = (function() {
      var close, cmd, output, saveData;

      saveData = null;

      output = null;

      cmd = null;

      function Command(text, _output) {
        cmd = getCommand(text);
        this.args = getArgs(text);
        output = _output;
      }

      close = function() {
        return storeDefinitions();
      };

      Command.prototype.exec = function(f) {
        return loadDefinitions((function(_this) {
          return function() {
            return f.apply(_this, _this.args);
          };
        })(this));
      };

      Command.prototype.finish = function() {
        var status;
        status = makeText(arguments);
        output(status);
        if (saveData) {
          return close();
        }
      };

      Command.prototype.run = function() {
        saveData = true;
        return this.exec(cmd.run);
      };

      Command.prototype.help = function() {
        saveData = false;
        return this.exec(cmd.help);
      };

      return Command;

    })();

    TabShepherd.prototype.commands = function() {
      return commands;
    };

    commands = {
      n: {
        alias: 'name'
      },
      name: {
        desc: 'Change the name of the current window definition',
        type: 'Managing window definitions',
        examples: {
          'ts name awesome': "Create a definition for the current window named 'awesome'."
        },
        help: function(newName) {
          return withCurrentWindow((function(_this) {
            return function(win) {
              if (win.name != null) {
                if (newName != null) {
                  return _this.finish("Press enter to change window name from '%s' to '%s'.", win.name, newName);
                } else {
                  return _this.finish("Enter a new name for this window (currently named '%s').", win.name);
                }
              } else {
                if (newName != null) {
                  return _this.finish("Press enter to name this window '%s'.", newName);
                } else {
                  return _this.finish('Enter a name for this window.');
                }
              }
            };
          })(this));
        },
        run: function(name) {
          if (!name) {
            return this.finish('No name provided.');
          }
          return withCurrentWindow((function(_this) {
            return function(win) {
              setName(win, name);
              return _this.finish();
            };
          })(this));
        }
      },
      attach: {
        desc: 'Attach the current window to a previously defined window definition',
        type: 'Managing window definitions',
        examples: {
          'ts attach work': 'Attach the current window to the existing window definition called \'work\'.'
        },
        help: function() {
          return withCurrentWindow((function(_this) {
            return function(win) {};
          })(this));
        },
        run: function() {
          return withCurrentWindow((function(_this) {
            return function(win) {};
          })(this));
        }
      },
      defs: {
        desc: 'List named window definitions',
        type: 'Managing window definitions',
        examples: {
          'ts defs': 'List all the window definitions that exist.'
        },
        help: function() {
          return this.finish('Press enter to list the window definitions.');
        },
        run: function() {
          var msg;
          msg = '';
          return withEachDefinition({
            run: (function(_this) {
              return function(def, win, name) {
                return msg += name + ' (' + (win ? 'window ' + win.id : 'no attached window') + ')\n';
              };
            })(this),
            then: (function(_this) {
              return function() {
                return _this.finish('Named windows:\n\n%s', msg);
              };
            })(this)
          });
        }
      },
      "new": {
        desc: 'Create a new empty window and assign it a definition',
        type: 'Managing window definitions',
        examples: {
          'ts new cats': "Create a new window with definition named 'cats'.",
          'ts new cats \\bcats?\\b': "Create a new window with definition named 'cats' and containing one pattern. Move no tabs."
        },
        help: function(name) {
          if (!name) {
            return this.finish('Enter a name for the new window.');
          }
          return withWindowNamed(name, (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish("There is already a window named '%s'.", name);
              } else {
                return _this.finish("Press enter to open a new window and name it '%s'.", name);
              }
            };
          })(this));
        },
        run: function(name) {
          if (!name) {
            return this.finish('No window name provided.');
          }
          return withWindow(name, (function(_this) {
            return function(win) {
              if (win) {
                return _this.finish("There is already a window named '%s'.", name);
              }
              return withNewWindow(name, function() {
                return _this.finish();
              });
            };
          })(this));
        }
      },
      clear: {
        desc: 'Clear window definitions',
        type: 'Managing window definitions',
        examples: {
          'ts clear recipes': 'Remove the window definition \'recipes\'. No tabs are affected.',
          'ts clear all data': 'Remove all window definitions from storage. No tabs are affected.'
        },
        help: function(name) {
          if (name === 'all data') {
            return finish('Press enter to clear all saved window definitions.');
          }
          return withWindowNamed(name, (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish('Press enter to clear window definition \'%s\'. Warning: currently assigned to a window.', name);
              } else if (getDefinition(name) != null) {
                return _this.finish('Press enter to clear window definition \'%s\', not currently assigned to a window.', name);
              } else {
                return _this.finish('Window definition \'%s\' not found.', name);
              }
            };
          })(this));
        },
        run: function(name) {
          if (name === 'all data') {
            storage.remove('windows', (function(_this) {
              return function() {
                return _this.finish('Cleared all window data.');
              };
            })(this));
          }
          return withWindowNamed(name, (function(_this) {
            return function(win) {
              if (win != null) {
                deleteDefinition(name);
                delete win.name;
                return _this.finish('Cleared window definition \'%s\' and removed it from a window.', name);
              } else if (getDefinition(name) != null) {
                deleteDefinition(name);
                return _this.finish('Cleared window definition \'%s\'.', name);
              } else {
                return _this.finish('Window definition \'%s\' not found.', name);
              }
            };
          })(this));
        }
      },
      clean: {
        desc: 'Clean window data, removing definitions for which no window is present',
        type: 'Managing window definitions',
        examples: {
          'ts clean': 'Clean window data, removing definitions for which no window is present. No tabs are affected.'
        },
        help: function() {
          return withEachDefinition({
            where: function(def, win) {
              return !win;
            },
            run: function(def, win, name) {
              return "'" + name + "'";
            },
            then: function(msg) {
              return this.finish(msg ? 'Press enter to clean unused window definitions: ' + msg : 'No window definitions need cleaning.');
            }
          });
        },
        run: function() {
          return withEachDefinition({
            where: function(def, win) {
              return !win;
            },
            run: (function(_this) {
              return function(def, win, name) {
                deleteDefinition(name);
                return "'" + name + "'";
              };
            })(this),
            then: function(msg) {
              return this.finish(msg ? 'Cleaned unused window definitions: ' + msg : 'No window definitions needed cleaning.');
            }
          });
        }
      },
      unnamed: {
        desc: 'Go to a window having no definition',
        type: 'Managing window definitions',
        examples: {
          'ts unnamed': 'Find a window with no definition if such exists, and focus it; else do nothing.'
        },
        help: function() {
          return withWindow((function(win) {
            return win.name == null;
          }), (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish('Press enter to go to an open window that has no definition.');
              } else {
                return _this.finish('All windows have a definition.');
              }
            };
          })(this));
        },
        run: function() {
          return withWindow((function(win) {
            return win.name == null;
          }), (function(_this) {
            return function(win) {
              if (win) {
                focus(win);
              }
              return _this.finish();
            };
          })(this));
        }
      },
      focus: {
        desc: 'Switch to the window with the given name',
        type: 'Changing focus',
        examples: {
          'ts focus work': "Focus the window named 'work'."
        },
        help: function(name) {
          if (!getDefinition(name)) {
            return this.finish('Type a defined window name.');
          } else {
            return this.finish("Press enter to focus window '%s'.", name);
          }
        },
        run: function(name) {
          if (!getDefinition(name)) {
            return this.finish("No such window '%s'.", name);
          } else {
            return withWindow(name, (function(_this) {
              return function(win) {
                if (win == null) {
                  return _this.finish("Window not found: '%s'.", name);
                } else {
                  focus(win);
                  return _this.finish();
                }
              };
            })(this));
          }
        }
      },
      go: {
        desc: 'Go to the tab matching the pattern, or if there are multiple matches perform an extract.',
        type: 'Changing focus',
        examples: {
          'ts go document': 'If there is one tab matching /document/, go there (i.e. ts find document), else behave as "ts extract document"'
        },
        help: function(pattern, name) {
          return withTabsMatching(pattern, (function(_this) {
            return function(matchingTabs) {
              if (matchingTabs.length === 1) {
                return _this.finish("Press enter to focus the single tab matching " + pattern + ".");
              } else if (matchingTabs.length > 1) {
                if (name == null) {
                  name = pattern;
                }
                return _this.finish("Press enter to extract the " + matchingTabs.length + " tabs matching " + pattern + " into a new window named " + name + ".");
              } else {
                return _this.finish("No tabs found matching " + pattern + ".");
              }
            };
          })(this));
        },
        run: function(pattern, name) {
          if (name == null) {
            name = pattern;
          }
          return withTabsMatching(pattern, (function(_this) {
            return function(matchingTabs) {
              if (matchingTabs.length === 1) {
                return tabs.get(matchingTabs[0], function(tab) {
                  return windows.update(tab.windowId, {
                    focused: true
                  }, function() {
                    return tabs.update(tab.id, {
                      highlighted: true
                    }, function() {});
                  });
                });
              } else if (matchingTabs.length > 1) {
                return withNewWindow(name, function(win) {
                  return tabs.move(matchingTabs, {
                    windowId: win.id,
                    index: -1
                  }, (function(_this) {
                    return function() {
                      win.name = name;
                      win.patterns = [pattern];
                      return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                        return _this.finish();
                      });
                    };
                  })(this));
                });
              } else {
                return _this.finish("No tabs found matching " + pattern + ".");
              }
            };
          })(this));
        }
      },
      f: {
        alias: 'find'
      },
      find: {
        desc: 'Go to the first tab found matching a pattern.',
        type: 'Changing focus',
        examples: {
          'ts find google.com': 'Focus the first tab found to match /google.com/.'
        },
        help: function(pattern) {
          return withTabsMatching(pattern, (function(_this) {
            return function(matchingTabs) {
              if (matchingTabs.length > 1) {
                return _this.finish('Press enter to focus the first of %s tabs matching /%s/.', matchingTabs.length, pattern);
              } else if (matchingTabs.length === 1) {
                return _this.finish('Press enter to focus the tab matching /%s/.', pattern);
              } else {
                return _this.finish('No matching tabs found for /%s/.', pattern);
              }
            };
          })(this));
        },
        run: function(pattern) {
          return withTabsMatching(pattern, (function(_this) {
            return function(matchingTabs) {
              if (matchingTabs.length >= 1) {
                return tabs.get(matchingTabs[0], function(tab) {
                  return windows.update(tab.windowId, {
                    focused: true
                  }, function() {
                    return tabs.update(tab.id, {
                      highlighted: true
                    }, function() {});
                  });
                });
              } else {
                return _this.finish("No matching tabs found for /" + pattern + "/.");
              }
            };
          })(this));
        }
      },
      b: {
        alias: 'bring'
      },
      bring: {
        desc: 'Bring tabs matching a pattern to the current window',
        type: 'Moving tabs',
        examples: {
          'ts bring cute.*bunnies.com': 'Bring tabs whose URLs match the given pattern (e.g. cutewhitebunnies.com and cutefluffybunnies.com) to the current window.',
          'ts bring': 'Bring tabs whose URLs match all this window\'s assigned patterns to this window.'
        },
        help: function() {
          return withCurrentWindow((function(_this) {
            return function(win) {
              var def, patterns;
              patterns = void 0;
              if (_this.args.length > 0) {
                patterns = _this.args;
              } else {
                def = getDefinition(win.name);
                if (!((def != null) && (def.patterns != null) && def.patterns.length === 0)) {
                  _this.finish('Enter one or more patterns. No assigned patterns exist for this window.');
                } else {
                  patterns = def.patterns;
                }
              }
              return withTabsMatching(patterns, function(matchingTabs) {
                var name, num;
                num = matchingTabs.length;
                if (num < 1) {
                  return _this.finish('No tabs found matching given pattern(s).');
                } else {
                  name = win.name ? "'" + win.name + "'" : '';
                  return _this.finish('Press enter to bring %s tabs matching %s pattern(s) to this window%s, or enter different patterns.', num, patterns.length, name);
                }
              });
            };
          })(this));
        },
        run: function() {
          return withCurrentWindow((function(_this) {
            return function(win) {
              var def, noneMsg, patterns;
              patterns = void 0;
              noneMsg = 'Error';
              if (_this.args.length > 0) {
                noneMsg = 'No tabs found matching %s given pattern%s:\n\n%s';
                patterns = _this.args;
              } else {
                def = getDefinition(win.name);
                if (!def || !def.patterns || def.patterns.length === 0) {
                  _this.finish('No patterns entered and this window has no assigned patterns.');
                } else {
                  noneMsg = 'No tabs found matching %s assigned pattern%s:\n\n%s';
                  patterns = def.patterns;
                }
              }
              return withTabsMatching(patterns, function(matchingTabs) {
                if (matchingTabs.length < 1) {
                  return this.finish(noneMsg, patterns.length, (patterns.length === 1 ? '' : 's'), mkString(patterns, '\n'));
                } else {
                  return tabs.move({
                    windowId: win.id,
                    index: -1
                  }, (function(_this) {
                    return function() {
                      return _this.finish();
                    };
                  })(this));
                }
              });
            };
          })(this));
        }
      },
      s: {
        alias: 'send'
      },
      send: {
        desc: 'Send the current tab to the window named in the argument',
        type: 'Moving tabs',
        examples: {
          'ts send research': "Send the current tab to the window named 'research'."
        },
        help: function(name) {
          var win;
          if (name == null) {
            return this.finish('Enter a window name to send this tab there.');
          } else {
            win = getDefinition(name);
            return this.finish("Press enter to send this tab to %swindow '%s'.", (win != null ? '' : 'new '), name);
          }
        },
        run: function(name) {
          return withActiveTab((function(_this) {
            return function(tab) {
              var existingWin;
              existingWin = getDefinition(name);
              if (existingWin != null) {
                return tabs.move(tab.id, {
                  windowId: existingWin.id,
                  index: -1
                });
              } else {
                return withNewWindow(name, function(win) {
                  tabs.move(tab.id, {
                    windowId: win.id,
                    index: -1
                  }, (function(_this) {
                    return function() {};
                  })(this));
                  return tabs.remove(win.tabs[win.tabs.length - 1].id, (function(_this) {
                    return function() {
                      return _this.finish();
                    };
                  })(this));
                });
              }
            };
          })(this));
        }
      },
      o: {
        alias: 'open'
      },
      open: {
        desc: 'Open a URL or search in a different window',
        type: 'Moving tabs',
        examples: {
          'ts open work google.com': "Opens the URL 'http://google.com' in the window 'work'."
        },
        help: function(name, url) {
          var win;
          if (!((name != null) && (url != null))) {
            return this.finish('Enter a window name followed by a URL to open the URL there.');
          } else {
            win = getDefinition(name);
            return this.finish("Press enter to open this URL in %swindow '%s'.", (win ? '' : 'new '), name);
          }
        },
        run: function(name, url) {
          if (!name || !url) {
            return this.finish('Enter a window name followed by a URL.');
          }
          ({
            openTab: (function(_this) {
              return function(win) {
                if (!/^http:\/\//.test(url)) {
                  url = 'http://' + url;
                }
                return tabs.create({
                  windowId: win.id,
                  url: url
                }, function() {
                  return _this.finish();
                });
              };
            })(this)
          });
          return withWindowNamed(name, (function(_this) {
            return function(existingWin) {
              if (existingWin != null) {
                return openTab(existingWin);
              } else {
                return withNewWindow(name, function(win) {
                  return openTab(win);
                });
              }
            };
          })(this));
        }
      },
      e: {
        alias: 'extract'
      },
      ex: {
        alias: 'extract'
      },
      extract: {
        desc: 'Extract tabs matching the pattern argument into a new window named with that pattern',
        type: 'Moving tabs',
        examples: {
          'ts extract social facebook.com twitter.com': "Create a new window, give it a definition named 'social', assign patterns /facebook.com/ and /twitter.com/ to that definition, and move all tabs whose URLs match the patterns there. This is effectively \"ts new social\", followed by \"ts assign facebook.com twitter.com\", then \"ts bring\". "
        },
        help: function() {
          var name, patterns;
          if (this.args.length === 0) {
            return this.finish('Enter a name or pattern.');
          } else {
            name = this.args[0];
            patterns = this.args.length === 1 ? [this.args[0]] : this.args.slice(1);
            return withTabsMatching(patterns, (function(_this) {
              return function(matchingTabs) {
                var num;
                num = matchingTabs.length;
                if (num < 1) {
                  return _this.finish('No tabs found matching the given pattern(s).');
                } else {
                  return _this.finish("Press enter to extract %s tab(s) matching /%s/%s into a new window named '%s'.", num, patterns[0], (patterns.length > 1 ? ', ...' : ''), name);
                }
              };
            })(this));
          }
        },
        run: function() {
          var name, patterns;
          if (this.args.length === 0) {
            return this.finish('Enter a name or pattern.');
          } else {
            name = this.args[0];
            patterns = this.args.length === 1 ? [this.args[0]] : this.args.slice(1);
            return withTabsMatching(patterns, (function(_this) {
              return function(matchingTabs) {
                if (matchingTabs.length < 1) {
                  return _this.finish('No tabs found matching the given pattern(s).');
                } else {
                  return withNewWindow(name, function(win) {
                    return tabs.move(matchingTabs, {
                      windowId: win.id,
                      index: -1
                    }, (function(_this) {
                      return function() {
                        win.name = name;
                        win.patterns = patterns;
                        return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                          return _this.finish();
                        });
                      };
                    })(this));
                  });
                }
              };
            })(this));
          }
        }
      },
      sort: {
        desc: 'Sort all tabs into windows by assigned patterns',
        type: 'Moving tabs',
        examples: {
          'ts sort': "Move all tab that matches a defined pattern to that pattern's window. Effectively, perform \"ts bring\" for each window."
        },
        help: function() {
          return this.finish('Press enter to sort all windows according to their assigned regexes.');
        },
        run: function() {}
      },
      merge: {
        desc: 'Merge all the tabs from a window into this window.',
        type: 'Moving tabs',
        examples: {
          'ts merge restaurants': "Move all the tabs from the window 'restaurants' into the current window and remove the 'restaurants' definition."
        },
        help: function() {},
        run: function() {}
      },
      assign: {
        desc: 'Assign a pattern to the current window',
        type: 'Managing URL patterns',
        examples: {
          'ts assign reddit.com': "Add /reddit.com/ to this window's assigned patterns. No tabs are affected."
        },
        help: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to assign to this window.');
          } else {
            return withWindowForPattern(pattern, (function(_this) {
              return function(currWin) {
                if (currWin != null) {
                  return _this.finish("Press enter to reassign /%s/ to this window from window '%s'.", pattern, currWin.name);
                } else {
                  return _this.finish('Press enter to assign /%s/ to this window.', pattern);
                }
              };
            })(this));
          }
        },
        run: function(pattern) {
          if (pattern == null) {
            return this.finish('No pattern provided.');
          } else {
            return withCurrentWindow(function(window) {
              return withWindowForPattern(pattern, function(currWin) {
                var msg;
                msg = void 0;
                if (currWin != null) {
                  if (unassignPattern(pattern, currWin)) {
                    msg = makeText('Pattern /%s/ was moved from window \'%s\' to window \'%s\'.', pattern, currWin.name, window.name);
                  } else {
                    this.finish('Could not unassign pattern %s from window %s.', pattern, currWin.name);
                  }
                }
                if (assignPattern(pattern, window)) {
                  return this.finish(msg);
                } else {
                  return this.finish('Could not assign pattern %s to window %s.', pattern, window.name);
                }
              });
            });
          }
        }
      },
      unassign: {
        desc: 'Remove a pattern assignment from the current window',
        type: 'Managing URL patterns',
        examples: {
          'ts unassign reddit.com': 'Remove /reddit.com/ from this window\'s patterns if it is assigned. No tabs are affected.'
        },
        help: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to remove from this window.');
          } else if (!containsPattern(pattern, window)) {
            return this.finish('Pattern /%s/ is not assigned to this window.', pattern);
          } else {
            return this.finish('Press enter to remove /%s/ from this window.', pattern);
          }
        },
        run: function(pattern) {
          if (pattern == null) {
            return this.finish('No pattern provided.');
          } else if (!containsPattern(pattern, window)) {
            return this.finish('Pattern /%s/ is not assigned to this window.');
          } else {
            return withCurrentWindow((function(_this) {
              return function(window) {
                if (unassignPattern(pattern, window)) {
                  return _this.finish();
                } else {
                  return _this.finish('Could not unassign pattern %s from window %s.', pattern, window.name);
                }
              };
            })(this));
          }
        }
      },
      patterns: {
        desc: 'List patterns assigned to the current window definition',
        type: 'Managing URL patterns',
        examples: {
          'ts patterns': 'List patterns assigned to the current window.'
        },
        help: function() {
          return this.finish('Press enter to list the patterns assigned to this window.');
        },
        run: function() {
          return withCurrentWindow((function(_this) {
            return function(window) {
              return _this.finish("Patterns assigned to window '%s':\n\n%s", window.name, listPatterns(window));
            };
          })(this));
        }
      },
      help: {
        desc: 'Get help on a command',
        type: 'Help',
        examples: {
          'ts help bring': 'Show the usage examples for the "bring" command.'
        },
        help: function(arg) {
          if (!arg || !commands[arg] || arg === 'help') {
            return this.finish(summarizeCommands(false));
          } else {
            return this.finish(arg + ': ' + getCommand(arg).desc);
          }
        },
        run: function(arg) {
          return this.finish(summarizeCommands(arg));
        }
      }
    };

    return TabShepherd;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.TabShepherd = TabShepherd;

}).call(this);
