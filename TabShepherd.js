// Generated by CoffeeScript 1.10.0
(function() {
  var TabShepherd, root,
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  TabShepherd = (function() {
    var Command, activateDefinition, alert, assignPattern, commands, containsPattern, countWindowsAndTabs, currentWindowOverride, definitions, deleteDefinition, focus, getArgs, getCommand, getCommandName, getDefForPattern, getDefinition, getId, getName, getPossibleCommands, inputChanged, inputEntered, isRegex, lastCommand, listPatterns, loadDefinitions, makeText, matchesAny, omnibox, plur, runtime, setName, showExamples, storage, storeDefinitions, summarizeCommands, tabs, unassignPattern, whenDefinition, windowMatching, windows, withActiveTab, withCurrentWindow, withEachDefinition, withEachWindow, withExistingWindow, withHighlightedTab, withInactiveDefinitions, withNewWindow, withTabsMatching, withWindow, withWindowForPattern, withWindowNamed;

    storage = null;

    omnibox = null;

    windows = null;

    tabs = null;

    runtime = null;

    definitions = null;

    currentWindowOverride = null;

    alert = null;

    lastCommand = null;

    function TabShepherd(chrome, _alert) {
      storage = chrome.storage.local;
      omnibox = chrome.omnibox;
      windows = chrome.windows;
      tabs = chrome.tabs;
      runtime = chrome.runtime;
      alert = _alert;
      storage.get(['windowDefs', 'lastCommand'], (function(_this) {
        return function(data) {
          console.log("storage got lastCommand " + data['lastCommand'] + " and defs " + data['windowDefs']);
          return definitions = data['windowDefs'] || {};
        };
      })(this));
      omnibox.onInputChanged.addListener(inputChanged);
      omnibox.onInputEntered.addListener(inputEntered);
    }

    inputChanged = function(text, suggest) {
      var c;
      c = new Command(text, function(res) {
        if (res) {
          return suggest([
            {
              content: ' ',
              description: res
            }
          ]);
        }
      });
      return c.help();
    };

    inputEntered = function(text, output) {
      console.log("Entered command: " + text);
      if ((output == null) || typeof output !== 'function') {
        output = getCommandName(text) !== 'help' ? function(res) {
          if (res) {
            return alert(res);
          }
        } : function(url) {
          return withCurrentWindow(function(win) {
            return tabs.create({
              windowId: win.id,
              url: url
            }, function() {});
          });
        };
      }
      if (text !== '.') {
        lastCommand = text;
      }
      return new Command(text, output).run();
    };

    getCommandName = function(text) {
      var idx;
      idx = text ? text.indexOf(' ') : -1;
      if (idx === -1) {
        return text;
      } else {
        return text.substring(0, idx);
      }
    };

    getPossibleCommands = function(text) {
      var k, name, results1, v;
      name = getCommandName(text);
      results1 = [];
      for (k in commands) {
        if (!hasProp.call(commands, k)) continue;
        v = commands[k];
        if (k.indexOf(name) === 0) {
          results1.push(k);
        }
      }
      return results1;
    };

    getCommand = function(text) {
      var cmds;
      cmds = getPossibleCommands(text);
      if (cmds.length === 1) {
        return commands[cmds[0]];
      } else {
        return commands['help'];
      }
    };

    getArgs = function(text) {
      text = text.trim();
      if (!/^\S+\s+\S+/.test(text)) {
        return [];
      }
      return text.replace(/^\S+\s+/, '').split(/\s+/);
    };

    TabShepherd.prototype.runCommand = function(cmd, output) {
      return inputEntered(cmd, output);
    };

    TabShepherd.prototype.makeText = function() {
      var a;
      return makeText.apply(null, (function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = arguments.length; j < len; j++) {
          a = arguments[j];
          results1.push(a);
        }
        return results1;
      }).apply(this, arguments));
    };

    makeText = function() {
      var a, arg, arr, j, len, m, matches, msg, v;
      arr = (function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = arguments.length; j < len; j++) {
          a = arguments[j];
          results1.push(a);
        }
        return results1;
      }).apply(this, arguments);
      if (arr.length === 0) {
        return void 0;
      }
      msg = arr.shift();
      if (arr.length === 0) {
        return msg;
      }
      matches = msg.match(/(%[spw])/g);
      if (matches == null) {
        return msg;
      }
      for (j = 0, len = matches.length; j < len; j++) {
        m = matches[j];
        arg = arr.shift();
        v = (function() {
          switch (m) {
            case '%p':
              if (isRegex(arg)) {
                return "/" + arg + "/";
              } else {
                return "'" + arg + "'";
              }
              break;
            case '%w':
              if (arg) {
                return "\"" + arg + "\"";
              } else {
                return '(unnamed)';
              }
              break;
            default:
              return arg;
          }
        })();
        msg = msg.replace(m, v != null ? v : '');
      }
      return msg;
    };

    isRegex = function(arg) {
      return /[*+|()$^?\[\]{}]/.test(arg);
    };

    getId = function(win) {
      if (typeof win === 'number') {
        return win;
      } else if (typeof win === 'object') {
        return win.id;
      } else {
        return alert("Can't find id from " + typeof win);
      }
    };

    showExamples = function(cmd) {
      var command, ex, examples, msg;
      if (commands[cmd] == null) {
        return '';
      }
      msg = '"' + cmd + '": ' + commands[cmd].desc + '.\n\nExamples:\n\n';
      command = commands[cmd];
      examples = command.examples;
      for (ex in examples) {
        msg += ex + "\n  " + examples[ex] + "\n\n";
      }
      return msg;
    };

    summarizeCommands = function(full) {
      var cmd, j, len, msg, name, type, types;
      if (full && full !== true) {
        return showExamples(full);
      }
      msg = '';
      if (full) {
        msg += 'Syntax: ts <command> <arguments>\n\n';
      }
      msg += 'Possible commands:' + (full ? '\n' : ' ');
      types = ['Moving tabs', 'Changing focus', 'Managing window definitions', 'Managing URL patterns', 'Informational'];
      for (j = 0, len = types.length; j < len; j++) {
        type = types[j];
        if (full) {
          msg += "  " + type + ":\n";
        }
        for (name in commands) {
          if (!hasProp.call(commands, name)) continue;
          cmd = commands[name];
          if (cmd.type === type) {
            if (full) {
              msg += "    " + name + ": " + cmd.desc + ".\n";
            } else {
              msg += name + ' ';
            }
          }
        }
      }
      return msg;
    };

    TabShepherd.prototype.focus = function(win) {
      return focus(win);
    };

    focus = function(win) {
      if (typeof win === 'object') {
        return windows.update(win.id, {
          focused: true
        }, function() {});
      } else {
        return windows.update(win, {
          focused: true
        }, function() {});
      }
    };

    TabShepherd.prototype.activateDefinition = function(name) {
      return activateDefinition(name);
    };

    activateDefinition = function(name) {
      return withNewWindow(name, function(win) {
        var def;
        def = getDefinition(name);
        if (def == null) {
          console.log("Didn't find def " + name + ", creating.");
          def = definitions[name] = {
            name: name
          };
        }
        def.id = win.id;
        return new Command('bring', null, win).run();
      });
    };

    TabShepherd.prototype.deleteDefinition = function(name) {
      return deleteDefinition(name);
    };

    deleteDefinition = function(name) {
      delete definitions[name];
      return storeDefinitions();
    };

    TabShepherd.prototype.getDefinition = function(name) {
      return getDefinition(name);
    };

    getDefinition = function(nameOrWin) {
      var def, name;
      if (typeof nameOrWin === 'string') {
        return definitions[nameOrWin];
      } else if (nameOrWin.id != null) {
        for (name in definitions) {
          if (!hasProp.call(definitions, name)) continue;
          def = definitions[name];
          if (def.id === nameOrWin.id) {
            return def;
          }
        }
      }
    };

    TabShepherd.prototype.storeDefinitions = function(cb) {
      return storeDefinitions(cb);
    };

    storeDefinitions = function(cb) {
      currentWindowOverride = null;
      return tabs.query({
        index: 0
      }, function(tabz) {
        var def, j, len, name, stored, tab;
        for (name in definitions) {
          if (!hasProp.call(definitions, name)) continue;
          def = definitions[name];
          for (j = 0, len = tabz.length; j < len; j++) {
            tab = tabz[j];
            if (tab.windowId === def.id) {
              def.firstUrl = tab.url;
            }
          }
        }
        console.log("storage is setting lastCommand " + lastCommand + " and defs " + definitions);
        stored = {
          windowDefs: definitions,
          lastCommand: lastCommand
        };
        return storage.set(stored, function() {
          if (runtime.lastError) {
            alert(runtime.lastError);
          }
          if (cb != null) {
            return cb();
          }
        });
      });
    };

    loadDefinitions = function(callback) {
      return storage.get(['windowDefs', 'lastCommand'], function(data) {
        lastCommand = data['lastCommand'];
        definitions = data['windowDefs'] || {};
        withEachDefinition({
          where: function(def, win) {
            return (win == null) && (def.firstUrl != null);
          },
          run: function(def) {
            return tabs.query({
              url: def.firstUrl
            }, function(tabz) {
              if (tabz != null ? tabz.length : void 0) {
                return def.id = tabz[0].windowId;
              }
            });
          }
        });
        return callback();
      });
    };

    TabShepherd.prototype.setName = function(win, name) {
      return setName(win, name);
    };

    setName = function(win, name) {
      var currName;
      currName = getName(win);
      if (name === currName) {
        return;
      }
      if (currName != null) {
        if (definitions[currName] != null) {
          if (currName !== name) {
            definitions[name] = definitions[currName];
            delete definitions[currName];
          }
        } else {
          definitions[name] = {
            id: win.id
          };
        }
      } else if (definitions[name] != null) {
        definitions[name].id = win.id;
      } else {
        definitions[name] = {
          id: win.id
        };
      }
      return definitions[name].name = name;
    };

    TabShepherd.prototype.getName = function(win) {
      return getName(win);
    };

    getName = function(win) {
      var id, name;
      id = getId(win);
      for (name in definitions) {
        if (!hasProp.call(definitions, name)) continue;
        if (definitions[name].id === id) {
          return name;
        }
      }
    };

    getDefForPattern = function(pattern) {
      var def, j, len, name, ref;
      for (name in definitions) {
        if (!hasProp.call(definitions, name)) continue;
        def = definitions[name];
        if (def.patterns) {
          ref = def.patterns;
          for (j = 0, len = ref.length; j < len; j++) {
            pattern = ref[j];
            if (pattern === def.patterns[i]) {
              return def;
            }
          }
        }
      }
    };

    TabShepherd.prototype.assignPattern = function(win, pattern) {
      return assignPattern(win, pattern);
    };

    assignPattern = function(win, pattern) {
      var def, j, len, name, p, ref;
      name = getName(win);
      if (name == null) {
        alert('Window has no name!');
        return false;
      }
      if (definitions[name] == null) {
        alert("Window " + name + " has no definition!");
        return false;
      }
      def = getDefinition(name);
      if (def.patterns == null) {
        def.patterns = [];
      }
      ref = def.patterns;
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        if (pattern === p) {
          return false;
        }
      }
      def.patterns.push(pattern);
      return true;
    };

    unassignPattern = function(window, pattern) {
      var def, i;
      if (window.name == null) {
        alert('Window has no name.');
        return false;
      }
      def = getDefinition(window);
      if (def == null) {
        alert('No definition found for name ' + window.name);
        return false;
      }
      if (def.patterns == null) {
        alert('No patterns found in window ' + window.name);
        return false;
      }
      i = 0;
      while (i < def.patterns.length) {
        if (def.patterns[i] === pattern) {
          def.patterns.splice(i, 1);
          return true;
        }
        i++;
      }
      alert("Could not delete pattern " + pattern + " from window '" + window.name + "'.");
      return false;
    };

    containsPattern = function(pattern, win) {
      var def, j, len, p, patterns;
      def = getDefinition(win);
      if (def == null) {
        alert('Unknown window definition' + win.name);
      }
      patterns = def.patterns;
      if (patterns == null) {
        return false;
      }
      for (j = 0, len = patterns.length; j < len; j++) {
        p = patterns[j];
        if (p === pattern) {
          return true;
        }
      }
      return false;
    };

    listPatterns = function(window) {
      var def, patt, patterns, ref;
      def = getDefinition(window);
      if (def == null) {
        return '';
      }
      patterns = (ref = def.patterns) != null ? ref : [];
      return ((function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = patterns.length; j < len; j++) {
          patt = patterns[j];
          results1.push(makeText("%p\n", patt));
        }
        return results1;
      })()).join('');
    };

    withWindowForPattern = function(pattern, callback) {
      return withEachDefinition({
        where: function(def, win) {
          var ref;
          return (win != null) && (def != null ? (ref = def.patterns) != null ? ref.indexOf(pattern) : void 0 : void 0) >= 0;
        },
        run: callback,
        otherwise: callback
      });
    };

    TabShepherd.prototype.countWindowsAndTabs = function(cb) {
      return countWindowsAndTabs(cb);
    };

    countWindowsAndTabs = function(cb) {
      return tabs.query({
        status: 'complete',
        windowType: 'normal'
      }, (function(_this) {
        return function(results) {
          var grouped, id, j, len, ref, ref1, tab, win;
          grouped = {};
          for (j = 0, len = results.length; j < len; j++) {
            tab = results[j];
            id = tab.windowId;
            if (grouped[id] == null) {
              grouped[id] = {};
            }
            win = grouped[id];
            win.tabs = ((ref = win.tabs) != null ? ref : 0) + 1;
            win.name = (ref1 = getName(id)) != null ? ref1 : "(unnamed)";
            win.def = getDefinition(win.name);
            win.id = id;
          }
          return cb(grouped);
        };
      })(this));
    };

    TabShepherd.prototype.withInactiveDefinitions = function(cb) {
      return withInactiveDefinitions(cb);
    };

    withInactiveDefinitions = function(cb) {
      return withEachDefinition({
        where: function(def, win) {
          return win == null;
        },
        reduce: function(def) {
          return def;
        },
        then: cb
      });
    };

    matchesAny = function(tab, patterns) {
      var j, len, p, r;
      for (j = 0, len = patterns.length; j < len; j++) {
        p = patterns[j];
        if (typeof p === 'boolean') {
          return p;
        }
        if (typeof p === 'function') {
          if (p(tab)) {
            return true;
          }
        } else if (/^\/.+\/$/.test(p)) {
          r = new RegExp(p.substring(1, p.length - 1));
          if (r.test(tab.url) || r.test(tab.title)) {
            return true;
          }
        } else if (isRegex(p)) {
          r = new RegExp(p);
          if (r.test(tab.url) || r.test(tab.title)) {
            return true;
          }
        } else {
          if (tab.url.toLowerCase().search(p) > -1 || tab.title.toLowerCase().search(p) > -1) {
            return true;
          }
        }
      }
      return false;
    };

    withTabsMatching = function(patterns, callback) {
      if (!patterns) {
        return callback([]);
      }
      if (typeof patterns === 'string' || typeof patterns === 'function') {
        patterns = [patterns];
      }
      if (patterns.length === 0 || patterns[0] === '') {
        return callback([]);
      }
      return tabs.query({
        status: 'complete',
        windowType: 'normal'
      }, (function(_this) {
        return function(results) {
          var tab;
          return callback((function() {
            var j, len, results1;
            results1 = [];
            for (j = 0, len = results.length; j < len; j++) {
              tab = results[j];
              if (matchesAny(tab, patterns)) {
                results1.push(tab.id);
              }
            }
            return results1;
          })());
        };
      })(this));
    };

    withEachWindow = function(args) {
      var action, condition, finish, otherwise, reduce;
      condition = args.where || function() {
        return true;
      };
      action = args.run;
      finish = args.then;
      reduce = args.reduce || function(msgs) {
        return msgs.join(',');
      };
      otherwise = args.otherwise;
      return windows.getAll({}, function(wins) {
        var def, j, len, msgs, win;
        msgs = [];
        for (j = 0, len = wins.length; j < len; j++) {
          win = wins[j];
          def = getDefinition(win);
          if (condition(win, def)) {
            msgs.push(action(win, def));
          }
        }
        if (finish != null) {
          return finish(reduce(msgs));
        } else if (msgs.length === 0 && (otherwise != null)) {
          return otherwise();
        }
      });
    };

    windowMatching = function(arg) {
      switch (typeof arg) {
        case 'string':
          return (function(_this) {
            return function(win) {
              return getName(win) === arg;
            };
          })(this);
        case 'number':
          return (function(_this) {
            return function(win) {
              return win.id === arg;
            };
          })(this);
        case 'function':
          return arg;
        case 'object':
          return (function(_this) {
            return function(win) {
              var k, v;
              return ((function() {
                var results1;
                results1 = [];
                for (k in arg) {
                  if (!hasProp.call(arg, k)) continue;
                  v = arg[k];
                  results1.push(win[k] === v);
                }
                return results1;
              })()).reduce(function(t, s) {
                return t && s;
              });
            };
          })(this);
        default:
          return alert("Can't use this argument type. " + (typeof arg) + " " + arg);
      }
    };

    withExistingWindow = function(arg, callback) {
      return withEachWindow({
        where: windowMatching(arg),
        run: callback
      });
    };

    TabShepherd.prototype.withWindow = function(arg, callback) {
      return withWindow(arg, callback);
    };

    withWindow = function(arg, callback) {
      return withEachWindow({
        where: windowMatching(arg),
        run: callback,
        otherwise: callback
      });
    };

    withEachDefinition = function(args) {
      var action, condition, finish, otherwise, reduce;
      condition = args.where || function() {
        return true;
      };
      action = args.run || function(def, win) {
        return def;
      };
      finish = args.then;
      reduce = args.reduce || function(msgs) {
        return msgs.join(',');
      };
      otherwise = args.otherwise;
      return windows.getAll({}, function(wins) {
        var def, findWin, msgs, name, win;
        findWin = function(name) {
          var j, len, win;
          for (j = 0, len = wins.length; j < len; j++) {
            win = wins[j];
            if (getName(win) === name) {
              return win;
            }
          }
        };
        msgs = [];
        for (name in definitions) {
          if (!hasProp.call(definitions, name)) continue;
          def = definitions[name];
          win = findWin(name);
          if (condition(def, win)) {
            msgs.push(action(def, win));
          }
        }
        if (finish != null) {
          return finish(reduce(msgs));
        } else if (msgs.length === 0 && (otherwise != null)) {
          return otherwise();
        }
      });
    };

    withActiveTab = function(callback) {
      return tabs.query({
        active: true,
        currentWindow: true
      }, function(tabz) {
        return callback(tabz[0]);
      });
    };

    withNewWindow = function(name, callback) {
      return windows.create({
        type: 'normal'
      }, function(win) {
        if (name != null) {
          if (getDefinition(name) == null) {
            definitions[name] = {
              name: name
            };
          }
          definitions[name].id = win.id;
          setName(win, name);
        }
        if (callback != null) {
          return callback(win);
        }
      });
    };

    TabShepherd.prototype.withCurrentWindow = function(callback) {
      return withCurrentWindow(callback);
    };

    withCurrentWindow = function(callback) {
      if (currentWindowOverride != null) {
        return callback(currentWindowOverride);
      } else {
        return windows.getCurrent({}, function(win) {
          return callback(win);
        });
      }
    };

    withWindowNamed = function(name, callback) {
      return windows.getAll({}, function(wins) {
        var j, len, win;
        for (j = 0, len = wins.length; j < len; j++) {
          win = wins[j];
          if (getName(win) === name) {
            return callback(win);
          }
        }
        return callback(void 0);
      });
    };

    withHighlightedTab = function(win, callback) {
      return tabs.query({
        active: true,
        windowId: win.id
      }, function(tabs) {
        if (tabs.length > 0) {
          return callback(tabs[0]);
        }
      });
    };

    whenDefinition = function(name, cases) {
      var process;
      process = function(def, win) {
        if (def == null) {
          if (cases.isUndefined != null) {
            return cases.isUndefined();
          } else {
            throw "Definition " + def + " is undefined, but isUndefined case not given.";
          }
        } else if ((def != null) && (win == null)) {
          if (cases.isUnused != null) {
            return cases.isUnused(def);
          } else {
            throw "Definition " + def + " is defined and unused, but isUnused case is not given.";
          }
        } else {
          if (cases.isInUse != null) {
            return cases.isInUse(def, win);
          } else {
            throw "Definition " + def + " is in use, but isInUse case is not given.";
          }
        }
      };
      return withEachDefinition({
        where: function(def) {
          return def.name === name;
        },
        run: process,
        otherwise: process
      });
    };

    plur = function(word, num) {
      var text;
      text = num === 1 ? word : /y$/.test(word) ? word.slice(0) + 'ies' : /s$/.test(word) ? word + 'es' : word + 's';
      return num + " " + text;
    };

    Command = (function() {
      var close, cmd, output, saveData;

      saveData = null;

      output = null;

      cmd = null;

      function Command(text, _output, onWindow) {
        var poss;
        if (onWindow != null) {
          currentWindowOverride = onWindow;
        }
        poss = getPossibleCommands(text);
        if (poss.length === 1) {
          this.name = poss[0];
          cmd = commands[this.name];
        } else {
          this.name = text.replace(/\s.*/, '');
          cmd = commands['help'];
        }
        this.args = getArgs(text);
        output = _output;
      }

      close = function() {
        return storeDefinitions();
      };

      Command.prototype.exec = function(f) {
        return loadDefinitions((function(_this) {
          return function() {
            return f.apply(_this, _this.args);
          };
        })(this));
      };

      Command.prototype.finish = function() {
        var a, args, status;
        console.log("Calling finish");
        currentWindowOverride = null;
        args = (function() {
          var j, len, results1;
          results1 = [];
          for (j = 0, len = arguments.length; j < len; j++) {
            a = arguments[j];
            results1.push(a);
          }
          return results1;
        }).apply(this, arguments);
        status = makeText.apply(null, args);
        if ((status != null) && (output != null)) {
          if (this.name === 'help') {
            output(status);
          } else {
            output(this.name + ": " + status);
          }
        }
        console.log("saveData? " + saveData);
        if (saveData) {
          return close();
        }
      };

      Command.prototype.run = function(cb) {
        saveData = true;
        return this.exec(cmd.run);
      };

      Command.prototype.help = function() {
        saveData = false;
        return this.exec(cmd.help);
      };

      return Command;

    })();

    TabShepherd.prototype.getCommands = function() {
      return commands;
    };

    commands = {
      tabs: {
        desc: "Show active tab information",
        type: 'Informational',
        examples: {
          "ts tabs": "Show information on each active tab."
        },
        help: function() {
          return this.finish("Press enter to see active tab information.");
        },
        run: function() {
          return tabs.query({
            active: true
          }, (function(_this) {
            return function(t) {
              var tab;
              return _this.finish(((function() {
                var j, len, results1;
                results1 = [];
                for (j = 0, len = t.length; j < len; j++) {
                  tab = t[j];
                  results1.push(tab.windowId + ": " + tab.url);
                }
                return results1;
              })()).join("\n"));
            };
          })(this));
        }
      },
      wins: {
        desc: "Show window information",
        type: 'Informational',
        examples: {
          "ts tabs": "Show window information."
        },
        help: function() {
          return this.finish("Press enter to see window information.");
        },
        run: function() {
          return windows.getAll((function(_this) {
            return function(wins) {
              var win;
              return _this.finish(((function() {
                var j, len, results1;
                results1 = [];
                for (j = 0, len = wins.length; j < len; j++) {
                  win = wins[j];
                  results1.push(win.id + ": " + (getName(win)));
                }
                return results1;
              })()).join("\n"));
            };
          })(this));
        }
      },
      window: {
        desc: "Show the current window's ID",
        type: 'Informational',
        examples: {
          "ts id": "Show the current window's ID."
        },
        help: function() {
          return withCurrentWindow((function(_this) {
            return function(win) {
              return _this.finish("This window's ID is %s and its name is %w", win.id, getName(win));
            };
          })(this));
        },
        run: function() {
          return withCurrentWindow((function(_this) {
            return function(win) {
              console.log("Is this on?");
              return _this.finish("This window's ID is %s and its name is %w", win.id, getName(win));
            };
          })(this));
        }
      },
      name: {
        desc: 'Change the name of the current window definition',
        type: 'Managing window definitions',
        examples: {
          'ts name awesome': "Create a definition for the current window named 'awesome'."
        },
        help: function(newName) {
          return withCurrentWindow((function(_this) {
            return function(win) {
              if (getName(win) != null) {
                if (newName != null) {
                  if (newName === getName(win)) {
                    return _this.finish("This window is already called %w.", newName);
                  } else {
                    return _this.finish("Press enter to change window name from %w to %w.", getName(win), newName);
                  }
                } else {
                  return _this.finish("Enter a new name for this window (currently named %w).", getName(win));
                }
              } else {
                if (newName != null) {
                  return _this.finish("Press enter to name this window %w.", newName);
                } else {
                  return _this.finish('Enter a name for this window.');
                }
              }
            };
          })(this));
        },
        run: function(name) {
          return withCurrentWindow((function(_this) {
            return function(win) {
              if (name == null) {
                return _this.finish('No name provided.');
              } else {
                setName(win, name);
                return _this.finish();
              }
            };
          })(this));
        }
      },
      defs: {
        desc: 'List named window definitions',
        type: 'Managing window definitions',
        examples: {
          'ts defs': 'List all the window definitions that exist.'
        },
        help: function() {
          return this.finish('Press enter to list the window definitions.');
        },
        run: function() {
          console.dir(definitions);
          return withEachDefinition({
            run: (function(_this) {
              return function(def, win) {
                var winText;
                winText = win != null ? 'window ' + win.id : 'no attached window';
                return def.name + " (" + winText + ")\n" + (def.firstUrl.substring(0, 21));
              };
            })(this),
            reduce: (function(_this) {
              return function(msgs) {
                return msgs.join("\n");
              };
            })(this),
            then: (function(_this) {
              return function(text) {
                return _this.finish('Named windows:\n\n%s', text);
              };
            })(this)
          });
        }
      },
      "new": {
        desc: 'Create a new window and assign it a definition',
        type: 'Managing window definitions',
        examples: {
          'ts new cats': "Create a new window with definition named 'cats'.",
          'ts new cats \\bcats?\\b': "Create a new window with definition named 'cats' and containing one pattern. Move no tabs."
        },
        help: function() {
          var name, patterns;
          name = arguments[0], patterns = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (!name) {
            return this.finish('Enter a name for the new window.');
          }
          return withWindowNamed(name, (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish("There is already a window named %w.", name);
              } else if (patterns.length === 0) {
                return _this.finish("Press enter to open a new window and name it %w.", name);
              } else if (patterns.length === 1) {
                return _this.finish("Press enter to open a new window named %w and assign it the pattern %p.", name, _this.args[1]);
              } else {
                return _this.finish("Press enter to open a new window named %w and assign it the given patterns.", name);
              }
            };
          })(this));
        },
        run: function() {
          var name, patterns;
          name = arguments[0], patterns = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (!name) {
            return this.finish('No window name provided.');
          }
          return withWindowNamed(name, (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish("There is already a window named %w.", name);
              }
              return withNewWindow(name, function(win) {
                var def, j, len, p;
                def = getDefinition(name);
                for (j = 0, len = patterns.length; j < len; j++) {
                  p = patterns[j];
                  if (def.patterns == null) {
                    def.patterns = [];
                  }
                  def.patterns.push(p);
                }
                return _this.finish();
              });
            };
          })(this));
        }
      },
      clear: {
        desc: 'Clear window definitions',
        type: 'Managing window definitions',
        examples: {
          'ts clear recipes': "Remove the window definition 'recipes'. No tabs are affected.",
          'ts clear *': "Remove all window definitions from storage. No tabs are affected."
        },
        help: function(name) {
          if (name == null) {
            return this.finish('Enter a window name or * to remove all.');
          }
          if (name === '*') {
            return this.finish('Press enter to clear all saved window definitions.');
          }
          return withWindowNamed(name, (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish("Press enter to clear window definition %w. Warning: currently assigned to a window.", name);
              } else if (getDefinition(name) != null) {
                return _this.finish("Press enter to clear window definition %w, not currently assigned to a window.", name);
              } else {
                return _this.finish("Window definition %w not found.", name);
              }
            };
          })(this));
        },
        run: function(name) {
          var def;
          if (name == null) {
            return this.finish('Enter a window definition name');
          }
          if (name === '*') {
            for (name in definitions) {
              if (!hasProp.call(definitions, name)) continue;
              def = definitions[name];
              deleteDefinition(name);
            }
            return this.finish('Cleared all window definitions.');
          } else {
            return withWindowNamed(name, (function(_this) {
              return function(win) {
                if (win != null) {
                  deleteDefinition(name);
                  return _this.finish("Cleared window definition %w and removed it from a window.", name);
                } else if (getDefinition(name) != null) {
                  deleteDefinition(name);
                  return _this.finish("Cleared window definition %w.", name);
                } else {
                  return _this.finish("Window definition %w not found.", name);
                }
              };
            })(this));
          }
        }
      },
      clean: {
        desc: 'Clean window data, removing definitions for which no window is present',
        type: 'Managing window definitions',
        examples: {
          'ts clean': 'Clean window data, removing definitions for which no window is present. No tabs are affected.'
        },
        help: function() {
          return withEachDefinition({
            where: function(def, win) {
              return !win;
            },
            run: function(def) {
              return "'" + def.name + "'";
            },
            then: (function(_this) {
              return function(msg) {
                return _this.finish(msg ? 'Press enter to clean unused window definitions: ' + msg : 'No window definitions need cleaning.');
              };
            })(this)
          });
        },
        run: function() {
          return withEachDefinition({
            where: function(def, win) {
              return !win;
            },
            run: (function(_this) {
              return function(def) {
                deleteDefinition(def.name);
                return "'" + def.name + "'";
              };
            })(this),
            then: (function(_this) {
              return function(msg) {
                return _this.finish(msg ? 'Cleaned unused window definitions: ' + msg : 'No window definitions needed cleaning.');
              };
            })(this)
          });
        }
      },
      unnamed: {
        desc: 'Go to a window having no definition',
        type: 'Managing window definitions',
        examples: {
          'ts unnamed': 'Find a window with no definition if such exists, and focus it; else do nothing.'
        },
        help: function() {
          return withWindow((function(win) {
            return getName(win) == null;
          }), (function(_this) {
            return function(win) {
              if (win != null) {
                return _this.finish('Press enter to go to an open window that has no definition.');
              } else {
                return _this.finish('All windows have a definition.');
              }
            };
          })(this));
        },
        run: function() {
          return withWindow((function(win) {
            return getName(win) == null;
          }), (function(_this) {
            return function(win) {
              if (win) {
                focus(win);
              }
              return _this.finish();
            };
          })(this));
        }
      },
      open: {
        desc: 'Open to the window with the given name, creating a new window if necessary',
        type: 'Changing focus',
        examples: {
          'ts focus work': "Focus the window with the definition \"work\" if it exists, otherwise create a window, give it definition \"work\" and focus it."
        },
        help: function(name) {
          if (name == null) {
            return this.finish("Enter a window name.");
          } else {
            return withWindow(name, (function(_this) {
              return function(win) {
                if (win != null) {
                  return _this.finish("Press enter to open window %w.", name);
                } else if (getDefinition(name) != null) {
                  return _this.finish("Press enter to open a new window for existing definition %w.", name);
                } else {
                  return _this.finish("Press enter to open new window %w.", name);
                }
              };
            })(this));
          }
        },
        run: function(name) {
          if (name == null) {
            return this.finish("Enter a window name.");
          } else {
            return withWindow(name, (function(_this) {
              return function(win) {
                if (win != null) {
                  focus(win);
                  return _this.finish();
                } else {
                  return withNewWindow(name, function(newWin) {
                    focus(newWin);
                    return _this.finish();
                  });
                }
              };
            })(this));
          }
        }
      },
      last: {
        desc: 'Focus the previously-focused window',
        type: 'Changing focus',
        examples: {
          'ts last': 'Focus the previously-focused window.'
        },
        help: function() {
          return tabs.query({
            active: true,
            lastFocusedWindow: true
          }, (function(_this) {
            return function(tabz) {
              var tab;
              if (tabz != null ? tabz.length : void 0) {
                tab = tabz[0];
                return withEachDefinition({
                  where: function(def, win) {
                    return win.id === tab.windowId;
                  },
                  run: function(def) {
                    return _this.finish("Press enter to focus the previously focused window %w.", def.name);
                  },
                  otherwise: function() {
                    return _this.finish("Press enter to focus the previously focused unnamed window.");
                  }
                });
              } else {
                return _this.finish("Press enter to focus the previously focused window.");
              }
            };
          })(this));
        },
        run: function() {}
      },
      go: {
        desc: 'Perform either "find", "open" or "new", depending on the arguments and number of matches',
        type: 'Changing focus',
        examples: {
          'ts go work': 'If there is a window called "work", focus it; else if there is one tab matching /work/, focus it (behave as "ts find work"); else create window "work" with pattern \'work\' and move applicable tabs there (behave as "ts extract work").',
          'ts go "work"': 'If there is a window named "work", focus it (behave as "ts open work"), otherwise create it (behave as "ts new work".)',
          'ts go /work/': 'Focus the first tab matching /work/.'
        },
        help: function(name) {
          if (name == null) {
            return this.finish("Enter a window name or URL pattern.");
          } else if (/^"/.test(name)) {
            name = name.replace(/"/g, '');
            if (getDefinition(name) == null) {
              return this.finish("Press enter to create a new window named %w.", name);
            } else {
              return this.finish("Press enter to focus window %w.", name);
            }
          } else {
            return whenDefinition(name, {
              isUndefined: (function(_this) {
                return function() {
                  return withTabsMatching(name, function(matchingTabsIds) {
                    if (matchingTabsIds.length === 1) {
                      return _this.finish("Press enter to focus the single tab matching %p.", name);
                    } else if (matchingTabsIds.length > 1) {
                      return _this.finish("Press enter to extract the %s tabs matching %p into a new window named %w.", matchingTabsIds.length, name, name);
                    } else {
                      return _this.finish("No tabs found matching %p.", name);
                    }
                  });
                };
              })(this),
              isUnused: (function(_this) {
                return function() {
                  return _this.finish("Press enter to create a window for inactive definition %w.", name);
                };
              })(this),
              isInUse: (function(_this) {
                return function() {
                  return _this.finish("Press enter to focus window %w.", name);
                };
              })(this)
            });
          }
        },
        run: function(name) {
          var winName;
          if (name == null) {
            return this.finish("Enter a window name or URL pattern.");
          } else if (/^"/.test(name)) {
            winName = name.replace(/"/g, '');
            if (getDefinition(winName) == null) {
              return withNewWindow(winName, (function(_this) {
                return function() {
                  return _this.finish();
                };
              })(this));
            } else {
              return withWindow(winName, (function(_this) {
                return function(win) {
                  if (win == null) {
                    return _this.finish("Window not found: %w.", winName);
                  }
                  focus(win);
                  return _this.finish();
                };
              })(this));
            }
          } else {
            whenDefinition(name, {
              isUndefined: (function(_this) {
                return function() {
                  return withTabsMatching(name, function(matchingTabsIds) {
                    if (matchingTabsIds.length === 1) {
                      return tabs.get(matchingTabsIds[0], function(tab) {
                        return windows.update(tab.windowId, {
                          focused: true
                        }, function() {
                          return tabs.update(tab.id, {
                            active: true
                          }, function() {});
                        });
                      });
                    } else if (matchingTabsIds.length > 1) {
                      return withNewWindow(name, function(win) {
                        return tabs.move(matchingTabsIds, {
                          windowId: win.id,
                          index: -1
                        }, function() {
                          setName(win, name);
                          assignPattern(win, name);
                          return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                            return _this.finish();
                          });
                        });
                      });
                    } else {
                      return _this.finish("No tabs found matching %p.", name);
                    }
                  });
                };
              })(this),
              isUnused: (function(_this) {
                return function() {
                  return withNewWindow(name, function(newWin) {
                    assignPattern(newWin, name);
                    return _this.finish();
                  });
                };
              })(this),
              isInUse: (function(_this) {
                return function(def, win) {
                  focus(win);
                  return _this.finish();
                };
              })(this)
            });
            if (getDefinition(name) != null) {
              return withWindow(name, (function(_this) {
                return function(win) {
                  if (win == null) {

                  } else {

                  }
                };
              })(this));
            } else {

            }
          }
        }
      },
      find: {
        desc: 'Go to the first tab found matching a pattern, never moving tabs',
        type: 'Changing focus',
        examples: {
          "ts find google.com": "Focus the first tab found to match 'google.com', or do nothing if no tab is found."
        },
        help: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to find a tab.');
          }
          return withTabsMatching(pattern, (function(_this) {
            return function(matchingTabs) {
              if (matchingTabs.length > 1) {
                return _this.finish("Press enter to focus the first of %s tabs matching %p.", matchingTabs.length, pattern);
              } else if (matchingTabs.length === 1) {
                return tabs.get(matchingTabs[0], function(tab) {
                  return windows.get(tab.windowId, {}, function(win) {
                    var name;
                    name = getName(win);
                    if (name != null) {
                      return _this.finish('Press enter to focus the tab matching %p in window %w.', pattern, name);
                    } else {
                      return _this.finish('Press enter to focus the tab matching %p.', pattern);
                    }
                  });
                });
              } else {
                return _this.finish('No matching tabs found for %p.', pattern);
              }
            };
          })(this));
        },
        run: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to find a tab.');
          }
          return withTabsMatching(pattern, (function(_this) {
            return function(matchingTabs) {
              if (matchingTabs.length >= 1) {
                return tabs.get(matchingTabs[0], function(tab) {
                  return windows.update(tab.windowId, {
                    focused: true
                  }, function() {
                    return tabs.update(tab.id, {
                      active: true
                    }, function() {});
                  });
                });
              } else {
                return _this.finish("No matching tabs found for %p.", pattern);
              }
            };
          })(this));
        }
      },
      bring: {
        desc: 'Bring tabs matching a pattern to the current window',
        type: 'Moving tabs',
        examples: {
          'ts bring cute.*bunnies.com': 'Bring tabs whose URLs match the given pattern (e.g. cutewhitebunnies.com and cutefluffybunnies.com) to the current window.',
          'ts bring': 'Bring tabs whose URLs match all this window\'s assigned patterns to this window.'
        },
        help: function() {
          var patterns;
          patterns = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return withCurrentWindow((function(_this) {
            return function(win) {
              var def, ref, usingAssigned;
              usingAssigned = patterns.length === 0;
              if (usingAssigned) {
                def = getDefinition(win);
                if (!(def != null ? (ref = def.patterns) != null ? ref.length : void 0 : void 0)) {
                  return _this.finish('Enter one or more patterns. No assigned patterns exist for this window.');
                }
                patterns = def.patterns;
              }
              return withTabsMatching(patterns, function(matchingTabs) {
                var extra, num;
                num = matchingTabs.length;
                if (num < 1) {
                  return _this.finish('No tabs found matching %s.', plur('given pattern', patterns.length));
                } else {
                  if (usingAssigned) {
                    extra = ", or enter different patterns";
                  }
                  return _this.finish('Press enter to bring %s matching %s to this window %w%s.', plur('tab', num), plur('pattern', patterns.length), getName(win), extra);
                }
              });
            };
          })(this));
        },
        run: function() {
          var patterns;
          patterns = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return withCurrentWindow((function(_this) {
            return function(win) {
              var def, usingAssigned;
              usingAssigned = patterns.length === 0;
              if (usingAssigned) {
                def = getDefinition(win);
                if (!def || !def.patterns || def.patterns.length === 0) {
                  return _this.finish('No patterns entered and this window has no assigned patterns.');
                }
                patterns = def.patterns;
              }
              return withTabsMatching(patterns, function(matchingTabs) {
                var pat, type;
                if (matchingTabs.length < 1) {
                  type = usingAssigned ? 'assigned pattern' : 'given pattern';
                  return _this.finish('No tabs found matching %s:\n\n%s', plur(type, patterns.length), ((function() {
                    var j, len, results1;
                    results1 = [];
                    for (j = 0, len = patterns.length; j < len; j++) {
                      pat = patterns[j];
                      results1.push(makeText("%p", pat));
                    }
                    return results1;
                  })()).join("\n"));
                } else {
                  return tabs.move(matchingTabs, {
                    windowId: win.id,
                    index: -1
                  }, function() {
                    return _this.finish();
                  });
                }
              });
            };
          })(this));
        }
      },
      group: {
        desc: 'Attempt to sort the current tab into a window according to pattern',
        type: 'Moving tabs',
        examples: {
          'ts group': "Match the current tab's URL and title against defined window patterns and send it to the first window that matches."
        },
        help: function() {
          return this.finish("Press enter to attempt to group this tab according to the defined window patterns.");
        },
        run: function() {
          var moved;
          moved = false;
          return withActiveTab((function(_this) {
            return function(tab) {
              return withEachDefinition({
                where: function(def, win) {
                  return !moved && win.id !== tab.windowId && matchesAny(tab, def.patterns || []);
                },
                run: function(def, win) {
                  return tabs.move(tab.id, {
                    windowId: win.id,
                    index: -1
                  }, function() {
                    moved = true;
                    return _this.finish();
                  });
                }
              });
            };
          })(this));
        }
      },
      send: {
        desc: 'Send the current tab to the window named in the argument, creating the window if necessary',
        type: 'Moving tabs',
        examples: {
          'ts send research': "Send the current tab to the window named 'research', first creating it if necessary."
        },
        help: function(name) {
          var win;
          if (name == null) {
            return this.finish('Enter a window name to send this tab there.');
          } else {
            win = getDefinition(name);
            return this.finish("Press enter to send this tab to %swindow %w.", (win != null ? '' : 'new '), name);
          }
        },
        run: function(name) {
          return withActiveTab((function(_this) {
            return function(tab) {
              return whenDefinition(name, {
                isUndefined: function() {
                  return withNewWindow(name, function(win) {
                    return tabs.move(tab.id, {
                      windowId: win.id,
                      index: -1
                    }, function() {
                      return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                        return _this.finish();
                      });
                    });
                  });
                },
                isUnused: function() {
                  return withNewWindow(name, function(win) {
                    return tabs.move(tab.id, {
                      windowId: win.id,
                      index: -1
                    }, function() {
                      return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                        return _this.finish();
                      });
                    });
                  });
                },
                isInUse: function(def, win) {
                  return tabs.move(tab.id, {
                    windowId: win.id,
                    index: -1
                  }, function() {
                    return _this.finish();
                  });
                }
              });
            };
          })(this));
        }
      },
      move: {
        desc: 'Move the current tab to the window named in the argument, creating the window if necessary; focus that window.',
        type: 'Moving tabs',
        examples: {
          'ts move research': "Send the current tab to the window named 'research', first creating it if necessary; focus 'research'."
        },
        help: function(name) {
          var def;
          if (name == null) {
            return this.finish('Enter a window name to send this tab there.');
          } else {
            def = getDefinition(name);
            return this.finish("Press enter to send this tab to %swindow %w.", (def != null ? '' : 'new '), name);
          }
        },
        run: function(name) {
          return withActiveTab((function(_this) {
            return function(tab) {
              return whenDefinition(name, {
                isUndefined: function() {
                  return withNewWindow(name, function(win) {
                    return tabs.move(tab.id, {
                      windowId: win.id,
                      index: -1
                    }, function() {
                      return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                        focus(win);
                        return _this.finish();
                      });
                    });
                  });
                },
                isUnused: function() {
                  return withNewWindow(name, function(win) {
                    return tabs.move(tab.id, {
                      windowId: win.id,
                      index: -1
                    }, function() {
                      return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                        focus(win);
                        return _this.finish();
                      });
                    });
                  });
                },
                isInUse: function(def, win) {
                  return tabs.move(tab.id, {
                    windowId: win.id,
                    index: -1
                  }, function() {
                    focus(win.id);
                    return _this.finish();
                  });
                }
              });
            };
          })(this));
        }
      },
      extract: {
        desc: 'Extract tabs matching the pattern arguments into a new window named with that pattern',
        type: 'Moving tabs',
        examples: {
          'ts extract google': "Create a new window \"google\", assign pattern 'google' to that definition, and move all tabs whose URLs match the pattern there.",
          'ts extract social facebook.com twitter.com': "Create a new window, give it a definition named 'social', assign patterns 'facebook.com' and 'twitter.com' to that definition, and move all tabs whose URLs match the patterns there. This is effectively \"ts new social\", followed by \"ts assign facebook.com twitter.com\", then \"ts bring\". "
        },
        help: function() {
          var name, patterns;
          if (this.args.length === 0) {
            return this.finish('Enter a name or pattern.');
          } else {
            name = this.args[0];
            patterns = this.args.length === 1 ? [this.args[0]] : this.args.slice(1);
            return withTabsMatching(patterns, (function(_this) {
              return function(matchingTabs) {
                var num;
                num = matchingTabs.length;
                if (num < 1) {
                  return _this.finish('No tabs found matching %p. Enter more args to use it as a name.', name);
                } else if (patterns.length > 1) {
                  return _this.finish("Press enter to extract %s matching %s patterns into a new window named %w.", plur("tab", num), patterns.length, name);
                } else {
                  return _this.finish("Press enter to extract %s matching %p into a new window named %w.", plur("tab", num), patterns[0], name);
                }
              };
            })(this));
          }
        },
        run: function() {
          var name, patterns;
          if (this.args.length === 0) {
            return this.finish('Enter a name or pattern.');
          } else {
            name = this.args[0];
            patterns = this.args.length === 1 ? [this.args[0]] : this.args.slice(1);
            return withTabsMatching(patterns, (function(_this) {
              return function(matchingTabs) {
                if (matchingTabs.length < 1) {
                  return _this.finish('No tabs found matching the given pattern(s).');
                } else {
                  return withNewWindow(name, function(win) {
                    return tabs.move(matchingTabs, {
                      windowId: win.id,
                      index: -1
                    }, function() {
                      var j, len, p;
                      setName(win, name);
                      for (j = 0, len = patterns.length; j < len; j++) {
                        p = patterns[j];
                        assignPattern(win, p);
                      }
                      return tabs.remove(win.tabs[win.tabs.length - 1].id, function() {
                        return _this.finish();
                      });
                    });
                  });
                }
              };
            })(this));
          }
        }
      },
      sort: {
        desc: 'Sort all tabs into windows by assigned patterns.',
        type: 'Moving tabs',
        examples: {
          'ts sort': "Check all tabs against the patterns for each open window definition. Move each matching tab to the window it matched."
        },
        help: function() {
          return this.finish('Press enter to sort all tabs according to their assigned patterns.');
        },
        run: function() {
          return tabs.query({
            pinned: false
          }, (function(_this) {
            return function(tabz) {
              var changed, j, len, name, num, tab;
              changed = {};
              for (j = 0, len = tabz.length; j < len; j++) {
                tab = tabz[j];
                withEachDefinition({
                  where: function(def) {
                    return (def.patterns != null) && matchesAny(tab, def.patterns);
                  },
                  run: function(def, win) {
                    return tabs.move(tab.id, {
                      windowId: win.id
                    }, function() {});
                  },
                  reduce: function(res) {
                    return (res != null ? res.length : void 0) || 0;
                  },
                  then: function(num) {
                    return changed[def.name] = (changed[def.name] || 0) + num;
                  }
                });
              }
              return _this.finish(((function() {
                var results1;
                results1 = [];
                for (name in changed) {
                  if (!hasProp.call(changed, name)) continue;
                  num = changed[name];
                  results1.push("Moved " + num + " tabs to window " + name);
                }
                return results1;
              })()).join("\n"));
            };
          })(this));
        }
      },
      merge: {
        desc: 'Merge all tabs and patterns from another window into this window.',
        type: 'Moving tabs',
        examples: {
          'ts merge restaurants': "Move all the tabs and patterns from window 'restaurants' into the current window and remove the 'restaurants' definition."
        },
        help: function(name) {
          if (name == null) {
            return this.finish('Enter a defined window name, or press enter to merge the window with the fewest tabs.');
          }
          return withWindow(name, (function(_this) {
            return function(fromWin) {
              if (fromWin == null) {
                return _this.finish('No such window %w', name);
              }
              return withTabsMatching((function(tab) {
                return tab.windowId === fromWin.id;
              }), function(tabz) {
                var patterns, ref, ref1;
                patterns = (ref = (ref1 = getDefinition(fromWin)) != null ? ref1.patterns : void 0) != null ? ref : [];
                return withCurrentWindow(function(toWin) {
                  return _this.finish('Press enter to move %s and %s from window %w to this window %w.', plur('tab', tabz.length), plur('pattern', patterns.length), name, getName(toWin));
                });
              });
            };
          })(this));
        },
        run: function(name) {
          var moveTabsToCurrentFrom;
          moveTabsToCurrentFrom = (function(_this) {
            return function(fromWin) {
              if (fromWin == null) {
                return _this.finish('No such window %w', name);
              }
              return withTabsMatching((function(tab) {
                return tab.windowId === fromWin.id;
              }), function(tabz) {
                var def;
                def = getDefinition(fromWin);
                if (def == null) {
                  return _this.finish("Window %w has no definition!");
                }
                return withCurrentWindow(function(currWin) {
                  var currDef, j, len, p, ref, ref1;
                  currDef = getDefinition(currWin);
                  if (currDef == null) {
                    return _this.finish("Current window has no definition to merge into!");
                  }
                  if (currDef.patterns == null) {
                    currDef.patterns = [];
                  }
                  ref1 = (ref = def.patterns) != null ? ref : [];
                  for (j = 0, len = ref1.length; j < len; j++) {
                    p = ref1[j];
                    currDef.patterns.push(p);
                  }
                  return tabs.move(tabz, {
                    windowId: currWin.id,
                    index: -1
                  }, function() {
                    return delete definitions[name];
                  });
                });
              });
            };
          })(this);
          if (name == null) {
            return countWindowsAndTabs((function(_this) {
              return function(info) {
                var inf, k, smallest;
                smallest = null;
                for (k in info) {
                  if (!hasProp.call(info, k)) continue;
                  inf = info[k];
                  if (inf.tabs < smallest.tabs) {
                    smallest = inf;
                  }
                }
                if (smallest != null) {
                  return withWindow(smallest.name, function(win) {
                    return moveTabsToCurrentFrom(win);
                  });
                }
              };
            })(this));
          } else {
            return withWindow(name, (function(_this) {
              return function(win) {
                return moveTabsToCurrentFrom(win);
              };
            })(this));
          }
        }
      },
      join: {
        desc: 'Merge all tabs and patterns from this window into another window.',
        type: 'Moving tabs',
        examples: {
          'ts join restaurants': "Move all the tabs and patterns from the current window into window 'restaurants' into and remove this window's definition."
        },
        help: function(name) {
          if (name == null) {
            return this.finish('Enter a defined window name, or press enter to join the window with the fewest tabs.');
          }
          return withCurrentWindow((function(_this) {
            return function(fromWin) {
              if (fromWin == null) {
                return _this.finish('No such window %w', name);
              }
              return withTabsMatching((function(tab) {
                return tab.windowId === fromWin.id;
              }), function(tabz) {
                var patterns, ref, ref1;
                patterns = (ref = (ref1 = getDefinition(fromWin)) != null ? ref1.patterns : void 0) != null ? ref : [];
                return withWindow(name, function(toWin) {
                  if (toWin != null) {
                    return _this.finish('Press enter to move %s and %s from this window %w to window %w.', plur('tab', tabz.length), plur('pattern', patterns.length), getName(fromWin), getName(toWin));
                  } else {
                    return _this.finish("Enter a defined window name to move this window's tabs there.");
                  }
                });
              });
            };
          })(this));
        },
        run: function(name) {
          var moveTabsFromCurrentTo;
          moveTabsFromCurrentTo = (function(_this) {
            return function(toWin) {
              if (toWin == null) {
                return _this.finish('No such window %w', name);
              }
              return withCurrentWindow(function(currWin) {
                return withTabsMatching((function(tab) {
                  return tab.windowId === currWin.id;
                }), function(tabz) {
                  var currDef, j, len, p, ref, ref1, toDef;
                  currDef = getDefinition(currWin);
                  toDef = getDefinition(toWin);
                  if (toDef == null) {
                    return _this.finish("Window %w has no definition!");
                  }
                  if (toDef.patterns == null) {
                    toDef.patterns = [];
                  }
                  ref1 = (ref = currDef != null ? currDef.patterns : void 0) != null ? ref : [];
                  for (j = 0, len = ref1.length; j < len; j++) {
                    p = ref1[j];
                    toDef.patterns.push(p);
                  }
                  return tabs.move(tabz, {
                    windowId: toWin.id,
                    index: -1
                  }, function() {
                    if ((currDef != null ? currDef.name : void 0) != null) {
                      return delete definitions[currDef.name];
                    }
                  });
                });
              });
            };
          })(this);
          if (name == null) {
            return countWindowsAndTabs((function(_this) {
              return function(info) {
                var inf, k, smallest;
                smallest = null;
                for (k in info) {
                  if (!hasProp.call(info, k)) continue;
                  inf = info[k];
                  if (inf.tabs < smallest.tabs) {
                    smallest = inf;
                  }
                }
                if (smallest != null) {
                  return withWindow(smallest.name, function(win) {
                    return moveTabsFromCurrentTo(win);
                  });
                }
              };
            })(this));
          } else {
            return withWindow(name, (function(_this) {
              return function(win) {
                return moveTabsFromCurrentTo(win);
              };
            })(this));
          }
        }
      },
      split: {
        desc: 'Split a window in two, moving half of the tabs to a new window.',
        type: 'Moving tabs',
        examples: {
          'ts split': 'Move the last half the tabs in the current window into a new window.'
        },
        help: function() {
          return this.finish("Press enter to split this window in two.");
        },
        run: function() {
          return withCurrentWindow((function(_this) {
            return function(win) {
              return withTabsMatching((function(tab) {
                return tab.windowId === win.id;
              }), function(matchingTabs) {
                if (matchingTabs.length >= 2) {
                  return withNewWindow(void 0, function(newWin) {
                    return tabs.move(matchingTabs.slice(matchingTabs.length / 2), {
                      windowId: newWin.id,
                      index: -1
                    }, function() {
                      return _this.finish();
                    });
                  });
                }
              });
            };
          })(this));
        }
      },
      assign: {
        desc: 'Assign a pattern to the current window',
        type: 'Managing URL patterns',
        examples: {
          'ts assign reddit.com': "Add /reddit.com/ to this window's assigned patterns. No tabs are affected."
        },
        help: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to assign to this window.');
          } else {
            return withWindowForPattern(pattern, (function(_this) {
              return function(currWin) {
                if (currWin != null) {
                  return _this.finish("Press enter to reassign %p to this window from window %w.", pattern, getName(currWin));
                } else {
                  return _this.finish('Press enter to assign %p to this window.', pattern);
                }
              };
            })(this));
          }
        },
        run: function(pattern) {
          if (pattern == null) {
            return this.finish('No pattern provided.');
          } else {
            return withCurrentWindow((function(_this) {
              return function(window) {
                return withWindowForPattern(pattern, function(currWin) {
                  var msg;
                  msg = void 0;
                  if (currWin != null) {
                    if (unassignPattern(currWin, pattern)) {
                      msg = makeText('Pattern %p was moved from window %w to window %w.', pattern, getName(currWin), getName(window));
                    } else {
                      _this.finish('Could not unassign pattern %p from window %w.', pattern, getName(currWin));
                    }
                  }
                  if (assignPattern(window, pattern)) {
                    return _this.finish(msg);
                  } else {
                    return _this.finish('Could not assign pattern %p to window %w.', pattern, getName(window));
                  }
                });
              };
            })(this));
          }
        }
      },
      unassign: {
        desc: 'Remove a pattern assignment from the current window',
        type: 'Managing URL patterns',
        examples: {
          'ts unassign reddit.com': 'Remove /reddit.com/ from this window\'s patterns if it is assigned. No tabs are affected.'
        },
        help: function(pattern) {
          if (pattern == null) {
            return this.finish('Enter a pattern to remove from this window.');
          } else if (!containsPattern(pattern, window)) {
            return this.finish('Pattern %p is not assigned to this window.', pattern);
          } else {
            return this.finish('Press enter to remove %p from this window.', pattern);
          }
        },
        run: function(pattern) {
          if (pattern == null) {
            return this.finish('No pattern provided.');
          } else if (!containsPattern(pattern, window)) {
            return this.finish('Pattern %p is not assigned to this window.');
          } else {
            return withCurrentWindow((function(_this) {
              return function(window) {
                if (unassignPattern(window, pattern)) {
                  return _this.finish();
                } else {
                  return _this.finish('Could not unassign pattern %s from window %w.', pattern, getName(window));
                }
              };
            })(this));
          }
        }
      },
      patterns: {
        desc: 'List patterns assigned to the current window definition',
        type: 'Managing URL patterns',
        examples: {
          'ts patterns': 'List patterns assigned to the current window.'
        },
        help: function() {
          return this.finish('Press enter to list the patterns assigned to this window.');
        },
        run: function() {
          return withCurrentWindow((function(_this) {
            return function(window) {
              return _this.finish("Patterns assigned to window %w:\n\n" + listPatterns(window), getName(window));
            };
          })(this));
        }
      },
      '.': {
        desc: 'Repeat the previously executed command.',
        type: 'Informational',
        examples: {
          'ts .': 'Repeat the previously executed command.'
        },
        help: function() {
          if (lastCommand != null) {
            return this.finish("Press enter to run the previous command: " + lastCommand);
          } else {
            return this.finish("No previous command found.");
          }
        },
        run: function() {
          if ((lastCommand != null) && lastCommand !== '.') {
            return this.finish(inputEntered(lastCommand));
          } else {
            return this.finish("No previous command found.");
          }
        }
      },
      help: {
        desc: 'Get help on a command',
        type: 'Informational',
        examples: {
          'ts help bring': 'Show usage examples for the "bring" command.'
        },
        help: function() {
          var cmd, cmds;
          if (this.name === 'help') {
            if (this.args.length > 0) {
              cmd = getCommand(this.args[0]);
              if ((cmd == null) || cmd === commands['help']) {
                return this.finish(this.args[0] + ": No matching command found.");
              } else {
                return this.finish(this.args[0] + ": " + cmd.desc);
              }
            } else {
              return this.finish('help: Enter a command name or press enter to see possible commands.');
            }
          } else {
            cmds = getPossibleCommands(this.name);
            if (cmds.length === 0) {
              return this.finish(this.name + ": No matching command found.");
            } else {
              return this.finish("[" + (cmds.join('/')) + "] Keep typing to narrow command results.");
            }
          }
        },
        run: function() {
          if (this.args.length > 0) {
            return this.finish("/help.html?command=" + this.args[0]);
          } else {
            return this.finish("/help.html");
          }
        }
      }
    };

    return TabShepherd;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.TabShepherd = TabShepherd;

}).call(this);
